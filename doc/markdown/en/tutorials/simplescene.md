# Урок 2. Создание простой сцены

Перед тем, как начать практические занятия, позвольте кое-что разъяснить. Xtreme3D - это библиотека динамической компоновки (DLL). А DLL - не что иное, как скомпилированный набор инструкций, написанных на каком-либо языке программирования, с целью их использования программами на любом другом языке, поддерживающим DLL. Xtreme3D, например, написан на Delphi, и в нем содержится около 580 таких инструкций. Назовем из для простоты функциями. В GameMaker можно написать скриптовые функции, каждая из которых будет вызывать определенную функцию из библиотеки. После этого можно будет вызывать функции через код GML по соответствующим названиям. Вот типичный пример функции Xtreme3D:

```gml
ObjectSetMaterial(object, "material");
```

Некоторые функции возвращают различные числовые и строковые значения. Например, при создании объекта возвращается его указатель, который необходимо записать в переменную для дальнейшей работы с объектом.

Следующий важный момент: константы. Многие функции используют в качестве аргументов числовые коды, и не всегда легко запомнить, какой код нужен для достижения нужного эффекта или включения нужного режима. Поэтому можно вместо кодов вводить соответствующие названия констант. По негласной традиции константы Xtreme3D выглядят так: `tmmCubeMapReflection`. Строчные буквы в начале (tmm) обозначают свойство, к которому относится константа. В данном случае это `TextureMappingMode`, а функция, задающая его - `MaterialSetTextureMappingMode("material", tmm)`, где вместо tmm подставляется нужная tmm-константа.

Помните, что константы являются частью Game Maker/GML и к самой Xtreme3D.dll они отношения не имеют.

Для начала работы вам понадобится проект GM с готовым набором функций и констант Xtreme3D. Шаблон пустого проекта можете взять из официального дистрибутива движка.

Откройте проект. В объекте o_engine уже назначены необходимые события. Так, следующий код загружает функции из библиотеки xtreme3d.dll в память и запускает работу движка: 

```gml
dll_init("xtreme3d.dll");
EngineCreate();
```

Идем дальше:

```gml
view = ViewerCreate(0, 0, window_get_width(), window_get_height(), PointerToReal(window_handle()));
ViewerSetLighting(view, true);
```

Для того, чтобы наблюдать что-либо в окне с игрой, понадобится вид (Viewer). Вид - это прямоугольник, в котором происходит отрисовка сцены Xtreme3D. Все, что за пределами этого прямоугольника, "принадлежит" встроенной графике GameMaker. Мы создали вид разрешением под размер окна, так что графики GameMaker и вовсе не будет видно. Позиция нашего вида на экране - (0, 0). По существу, это координата левого верхнего угла вида, относительно левого верхнего угла окна.

Также в функцию `ViewerCreate` передается `window_handle()`, идентификатор главного окна игры. Таким образом, Вд будет "привязан" к окну игры GameMaker, что нам и нужно, но Xtreme3D может рендерить в любое окно.

Вид - это тоже объект, поэтому при создании мы заносим его идентификатор в переменную, в нашем случае - view. Мы можем использовать идентификатор вида для изменения его свойств. В данный момент нас интересует только одно - использование освещения (`ViewerSetLighting`). Если выключить освещение (`false`), все объекты будут выглядеть плоскими и необъемными. Поэтому мы его включаем (`true`). Правда, для того, чтобы освещение работало, надо еще создать источники света:

```gml
light = LightCreate(lsOmni, 0);
ObjectSetPosition(light, 0, 18, 0);
```

Функция `LightCreate` создает источник света и возвращает его идентификатор, так как свет - это тоже объект. В Xtreme3D есть три типа источников света - точечный (константа `lsOmni`), направленный (`lsSpot`) и параллельный (`lsParallel`). Точечный излучает свет равномерно во всех направлениях (как, например, лампочка), направленный светит в пределах конуса (как фонарик), параллельный испускает параллельные лучи в направлении одной оси (имитация солнечного света). Мы можем назначить источнику света родителя, но, поскольку никаких сценических объектов у нас пока нет, подставляем вместо родителя 0. Создав точечный источник света, можно уточнить его положение в пространстве - точка (0, 18, 0).

Мы все еще ничего не увидим, поскольку свету нечего освещать. Создадим какой-нибудь простейший видимый объект. Но перед этим необходимо создать корневые объекты нашей сцены:

```gml
global.back = DummycubeCreate(0);
global.scene = DummycubeCreate(0);
global.front = DummycubeCreate(0);
```

Функция DummycubeCreate создает даммикуб и возвращает его идентификатор. Объект, носящий это забавное название, играет важную роль в формировании иерархии. Даммикуб невидим, это как бы объект-призрак. Но, в то же время, он обладает всеми обычными свойствами объектов, которые мы рассмотрели в предыдущей главе - координатами в пространстве, векторами Direction, Up, Left и т.д. Его можно свободно перемещать, вращать и масштабировать. Даммикуб может иметь родителя и потомков. В данном случае мы создали три глобальных корневых даммикуба. Корневых - потому что выше их в иерархии ничего не будет. Все остальные сценические объекты будут потомками этих трех даммикубов:

- `global.back` - родитель для объектов на заднем плане (небо, фон и т.д.)
- `global.scene` - родитель для объектов на сценическом плане (все 3D-объекты)
- `global.front` - родитель для 2D-объектов на экране (спрайты, индикаторы, текст и т.д.)

Важно соблюсти именно этот порядок создания даммикубов - сначала задний план, потом сцена, потом экран. Это необходимо для того, чтобы движок мог отрисовать объекты в правильном порядке. Этот порядок называется сортировкой: все объекты отрисовываются в том порядке, в котором были созданы они сами или их родители. Использовать именно такую структуру корневых объектов необязательно, вы можете создать свою, но подход с тремя даммикубами для трех планов является самым распространенным.

Создадим первый объект сценического плана - плоскость:

```gml
plane = PlaneCreate(0, 64, 64, 8, 8, global.scene);
ObjectPitch(plane, 90);
```

Плоскость - один из примитивов, простых геометрических тел, которые генерируются движком. Функция PlaneCreate создает плоскость и возвращает ее идентификатор. Рассмотрим ее аргументы:

- 0 - определяет, нужно ли представить плоскость одним квадратом (сокращенно - квадом), или разбить на несколько; нам для красивого освещения нужно несколько, поэтому указываем 0;
- 64, 64 - размер плоскости;
- 8, 8 - количество квадов. В общей сложности плоскость будет разбита на 8 * 8 = 64 квадов;
- `global.scene` - родитель.

Созданная нами плоскость по умолчанию вертикальна, поэтому надо ее повернуть на 90 градусов по оси X. Если помните, поворот по оси X называется Pitch, поэтому нам нужна функция `ObjectPitch`.

Мы все еще ничего не увидим, так как не создали камеру. Камера - это тоже объект, невидимый, как и даммикуб. Используется для проекции трехмерной сцены на плоскость экрана, а точнее - на плоскость вида. Проекция осуществляется из точки положения камеры в направлении вектора Direction камеры. Проще говоря, куда смотрит камера, то мы и видим, как и в реальной жизни.

```gml
camPos = DummycubeCreate(global.scene);
ObjectSetPosition(camPos, 0, 10, 0);
camera = CameraCreate(camPos);
ViewerSetCamera(view, camera);
```

Перед созданием камеры мы создали для нее родителя - еще один даммикуб `camPos`. Это сделано для того, чтобы сама камера могла свободно вращаться и смотреть в любые стороны, а ее движение в плоскости XZ контролировалось через этот даммикуб - такой подход гораздо проще и удобнее, чем вручную ограничивать движение камеры напрямую.

Функция `ViewerSetCamera` указывает Виду, какую Камеру использовать для передачи изображения.

Как видите, пока все достаточно просто. Осталось только последнее: 

```gml
application_surface_draw_enable(false);
game_set_speed(60, gamespeed_fps);
alarm[0] = room_speed;
```

В событии Alarm 0:

```gml
draw_enable_drawevent(false);
```

Этим мы отключаем автоматическую отрисовку графики GameMaker - если обе графические системы будут работать одновременно, экран будет мерцать. Счетчик Alarm 0 нужен для того, чтобы `draw_enable_drawevent` вызывалась после отрисовки первого кадра, иначе не появится окно игры.

Сцену мы создали, осталось добавить ей интерактивность. Создайте обработчик события Step и в нем добавьте следующий код: 

```gml
var dt = 1.0 / 60;

if keyboard_check(vk_left) ObjectTurn(camPos, -5 * dt);
if keyboard_check(vk_right) ObjectTurn(camPos, 5 * dt);
if keyboard_check(vk_up) ObjectMove(camPos, -5 * dt);
if keyboard_check(vk_down) ObjectMove(camPos, 5 * dt);
```

Теперь, когда пользователь нажмет клавишу, скажем, "Вверх", камера будет двигаться вперед (соответственно и для клавиши "Назад"). Для поворота камеры используются клавиши "Влево" и "Вправо". Поворот осуществляется по оси Y (Turn), поэтому используется функция `ObjectTurn`. Заметьте, что для трансформации мы используем не саму камеру, а ее родителя `camPos`. Благодаря этому мы потом сможем вращать камеру при помощи мыши. 

```gml
EngineUpdate(dt);
ViewerRender(view);
```

Эти две функции надо обязательно вызвать, иначе движок будет "парализован". `EngineUpdate` обновляет состояние объектов сцены, `ViewerRender` совершает отрисовку указанного Вида. В функцию `EngineUpdate` необходимо передать шаг времени для обновления анимации. Он измеряется в секундах и равен времени, которое проходит между двумя кадрами. Обычно его устанавливают равным 1/60 - это значение соответствует стандартной частоте обновления монитора.

Это все! Убедитесь, что в комнате есть экземпляр `o_engine`, и можете запускать игру.

Поздравляем, вы создали свое первое приложение на Xtreme3D!

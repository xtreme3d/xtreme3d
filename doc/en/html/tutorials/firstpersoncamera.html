<HTML>
<HEAD>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<TITLE>Камера от первого лица</TITLE>
<LINK href="../data/style.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>

<DIV ALIGN=justify>

<H1 class=pagetitle>Урок 4<BR>Камера от первого лица</H1>

<A><B>Уровень:</B> начинающий</A>
<BR><A><B>Версия Xtreme3D:</B> 3.0.x</A>
<BR><A><B>Автор урока:</B> Gecko</A><A class=ntext>
<BR>
<BR>На уроке 3 мы рассмотрели простейший вариант камеры от первого лица - она управлялась клавишами-стрелками. Между тем, в абсолютном большинстве современных игр в этом случае используется управление мышью. Давайте рассмотрим, как реализовать его средствами Xtreme3D.
<BR>
<BR>Начнем с того, что создадим родительский Манекен для камеры - camPos. Мы будем двигать не камеру, а его.
<BR>
<BR><A>camPos = <A class=func2link href=../functions/dummycube.htm#DummycubeCreate>DummycubeCreate</A>(<B>global</B>.scene);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectSetPosition>ObjectSetPosition</A>(camPos, 0, 2, 0);</A>
<BR><A>camera = <A class=func2link href=../functions/camera.htm#CameraCreate>CameraCreate</A>(camPos);</A>
<BR><A class=func2link href=../functions/viewer.htm#ViewerSetCamera>ViewerSetCamera</A>(view1, camera);</A>
<BR>
<BR>Дело в том, что камера должна двигаться только в плоскости XZ - иными словами, не должна "летать" по воздуху. Мы будем поворачивать объект camPos по оси Y, когда пользователь сместит мышь по горизонтали - таким образом, можно будет управлять направлением движения. Смещение мыши по вертикали вызовет локальный поворот объекта camera по оси X - таким образом, пользователь сможет смотреть вверх и вниз, но это никак не повлияет на направление движения, ведь camera наследует движение от camPos.
<BR>
<BR>Объявим также следующие переменные:
<BR>
<BR><A>centerX = </A><A class=type>display_get_width</A>() / 2;</A>
<BR><A>centerY = </A><A class=type>display_get_height</A>() / 2;</A>
<BR>
<BR>Это координаты центра экрана. Мы будем считывать смещение мыши относительно этой точки, а затем возвращать в нее курсор.
<BR>
<BR>Можно также сразу поместить курсор в центр экрана, чтобы на начало игры камера смотрела строго вперед:
<BR>
<BR><A class=type>display_mouse_set</A>(centerX, centerY);</A>
<BR>
<BR>Теперь переходим к событию Step. Следующий код вычисляет смещение курсора мыши относительно центра экрана и поворачивает camPos и camera на соответствующие углы, deltaX и deltaY:
<BR>
<BR><A>deltaX = (centerX - <A class=type>display_mouse_get_x</A>()) / 3;</A>
<BR><A>deltaY = (centerY - <A class=type>display_mouse_get_y</A>()) / 3;</A>
<BR><A class=func2link href=../functions/object.htm#ObjectRotate>ObjectRotate</A>(camera, deltaY, 0, 0);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectRotate>ObjectRotate</A>(camPos, 0, -deltaX, 0);</A>
<BR><A class=type>display_mouse_set</A>(centerX, centerY);</A>
<BR>
<BR>Осталось реализовать движение. Мы будем использовать стандартную для игр от первого лица раскладку WASD:
<BR>
<BR><A>dt = 1.0 / room_speed;</A>
<BR><A><B>if</B> <A class=type>keyboard_check</A>(<A class=type>ord</A>('W')) <A class=func2link href=../functions/object.htm#ObjectMove>ObjectMove</A>(camPos, -10 * dt);</A>
<BR><A><B>if</B> <A class=type>keyboard_check</A>(<A class=type>ord</A>('A')) <A class=func2link href=../functions/object.htm#ObjectStrafe>ObjectStrafe</A>(camPos, 10 * dt);</A>
<BR><A><B>if</B> <A class=type>keyboard_check</A>(<A class=type>ord</A>('D')) <A class=func2link href=../functions/object.htm#ObjectStrafe>ObjectStrafe</A>(camPos, -10 * dt);</A>
<BR><A><B>if</B> <A class=type>keyboard_check</A>(<A class=type>ord</A>('S')) <A class=func2link href=../functions/object.htm#ObjectMove>ObjectMove</A>(camPos, 10 * dt);</A>
<BR>
<BR>Смысл умножения на dt в следующем. Если двигать объекты с фиксированной скоростью, их фактическая скорость движения будет привязана к кадровой частоте приложения. То есть, например, если мы двигаем объект на 10 единиц за кадр, скорость при частоте в 60 FPS будет равняться 10 * 60 = 600 единицам в секунду. При частоте 120 FPS, соответственно - 10 * 120 = 1200. В итоге, объект будет двигаться быстрее или медленнее, в зависимости от FPS. Это совсем не то, что нам нужно, поэтому нужно задавать скорость в других величинах, не привязанных к кадру. Например - в единицах в секунду. Следовательно, кадровая скорость будет равна V / FPS, где V - скорость. Мы просто выясняем, на сколько объект должен переместиться за один кадр, если в секунду он перемещается на V единиц. Таким образом, объект будет двигаться с правильной скоростью при любой кадровой частоте.
<BR>
<BR>Чтобы не загромождать код делениями (деление, как известно, относительно медленная операция), мы вместо этого умножаем скорость на 1 / FPS - это значение можно рассчитать только один раз. Оно также называется шагом времени (именно этот шаг времени следует передавать в функцию Update, о чем говорилось на уроке 2). В Game Maker 8 кадровая частота (FPS) обычно фиксирована и задается в настройках комнаты (Room speed). Ее можно выставить равной 60 или 120.
</A>

</DIV>

</BODY>
</HTML>

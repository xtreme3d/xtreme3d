<!DOCTYPE html>
<html lang="en">
<head>
    <title>Tutorial 3. Object hierarchy</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="3">Урок 3. Иерархия объектов</h1>
<p>Понятие иерархии нам уже встречалось, но до сих мы не рассматривали ее на практике. Многие, кто не знаком с данным подходом организации объектов, и не подозревают, о какой громадной экономии сил и времени здесь идет речь. Иерархия позволяет безо всякого труда сделать то, что слишком тяжело или вообще невозможно без ее использования. Дело касается специфики перемещений объектов в некоторых особых случаях.</p>
<p>Представьте себе, к примеру, такую ситуацию: необходимо смоделировать простейшую звездную систему - солнце и вращающуюся вокруг нее планету. Вокруг планеты, в свою очередь, вращается спутник. Для простоты будем пока мыслить в двумерном пространстве. Как можно поступить?</p>
<p>Пусть Sun - солнце, Planet - планета, Moon - спутник. У каждого объекта есть две координаты - X и Y, а также угол вращения вокруг своей оси - A. Тогда (в псевдокоде):</p>
<pre><code class="hljs"><span class="hljs-attr">Sun.X</span> = <span class="hljs-number">0</span>
<span class="hljs-attr">Sun.Y</span> = <span class="hljs-number">0</span>
<span class="hljs-attr">Planet.X</span> = Sun.X + cos(Sun.A) * <span class="hljs-number">10</span>
<span class="hljs-attr">Planet.Y</span> = Sun.Y + sin(Sun.A) * <span class="hljs-number">10</span>
</code></pre>
<p>Принимая во внимание, что расстояние между солнцем и планетой равно 10 условным единицам. При повороте солнца вокруг своей оси, планета будет вращаться вокруг нее, перемещаясь на координаты, вычисленные из угла поворота солнца и искомого расстояния. Нетрудно теперь аналогично рассчитать и координаты спутника:</p>
<pre><code class="hljs"><span class="hljs-attr">Moon.X</span> = Planet.X + cos(Planet.A) * <span class="hljs-number">2</span>
<span class="hljs-attr">Moon.Y</span> = Planet.Y + sin(Planet.A) * <span class="hljs-number">2</span>
</code></pre>
<p>Но вручную это делать не всегда удобно. Особенно, если в системе не три объекта, а, скажем, все десять. Или расположение объектов периодически меняется (например, спутник отрывается от одной планеты и переходит к другой). Разумнее будет автоматизировать процесс, введя для каждого объекта свойство родителя (Parent):</p>
<pre><code class="hljs"><span class="hljs-attr">Planet.Parent</span> = Sun
<span class="hljs-attr">Moon.Parent</span> = Planet
</code></pre>
<p>И обновлять координаты объектов одинаковой для всех формулой:</p>
<pre><code class="hljs"><span class="hljs-variable"><span class="hljs-class">Object</span>.X</span> = <span class="hljs-variable"><span class="hljs-class">Object</span>.Parent.X</span> + <span class="hljs-function"><span class="hljs-title">cos</span>(<span class="hljs-variable"><span class="hljs-class">Object</span>.Parent.A</span>) * <span class="hljs-number">2</span>
<span class="hljs-variable"><span class="hljs-class">Object</span>.Y</span> = <span class="hljs-variable"><span class="hljs-class">Object</span>.Parent.Y</span> + <span class="hljs-title">sin</span>(<span class="hljs-variable"><span class="hljs-class">Object</span>.Parent.A</span>) * <span class="hljs-number">2</span>
</span></code></pre>
<p>Так и реализуется простейшая иерархия.</p>
<p>С двумерной графикой все относительно просто. Но как быть с трехмерной? В трехмерной графике вдобавок к синусам и косинусам используются векторы и матрицы. Операции с ними довольно ресурсоемки и чрезвычайно сложны для осмысления новичком. К тому же, слишком часто осуществлять такие операции на уровне GML нерационально: для хранения массивов под матрицы потребуется больше памяти, а математические операции с ними снизят FPS. Но не все так ужасно. Xtreme3D берет на себя все ресурсоемкие вычисления, исполняя их на уровне машинного кода, поэтому ее иерархия будет работать гораздо быстрее и точнее, чем написанная вручную на GML.</p>
<p>При использовании встроенной иерархии Xtreme3D вся работа сводится к указанию родителей для объектов. Весь фокус в том, что потомок наследует координатную систему родителя. Например, координаты родителя (X, Y, Z) становятся координатами центра, относительно которого ведется отсчет собственных координат его потомка (X+x, Y+y, Z+z). Потомок, в свою очередь, передает собственные координаты своим потомкам, и так далее. Собственные координаты объекта называются локальными.</p>
<p>Координатная система может быть трансформирована перемещением, поворотом или масштабированием. Поворот локальной координатной системы родителя вызывает изменение направления осей в унаследованной координатной системе потомка, что автоматически приводит к его вращению в пространстве. Если в момент вращения потомок был на некотором расстоянии от центра унаследованной им системы координат, это будет выглядеть, как вращение потомка вокруг своего родителя. Совсем как в нашем примере!</p>
<p>Для создания системы с солнцем и планетами в нашем случае достаточно написать что-то вроде этого:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">sun = SphereCreate(<span class="hljs-number">4</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, <span class="hljs-symbol">global</span>.scene);
ObjectSetPosition(sun, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
planet = SphereCreate(<span class="hljs-number">1</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, sun);
ObjectSetPosition(planet, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">10</span>);

moon = SphereCreate(<span class="hljs-number">0.5</span>, <span class="hljs-number">24</span>, <span class="hljs-number">24</span>, planet);
ObjectSetPosition(moon, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>);
</code></pre>
<p>Функция SphereCreate создает сферу. Необходимо указать ее радиус, а также количество меридиан и параллелей. У нашего солнца радиус равен 4, у планеты — 1, у спутника — 0.5. Меридианы и параллели (slices, stacks) делят сферу на квадраты, количество которых задает качество внешнего вида сферы. Обычно достаточно указать 24 меридиана и 24 параллели.</p>
<p>Теперь можно в событии Step поворачивать солнце и планету:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">ObjectTurn(sun, <span class="hljs-number">2</span>);
ObjectTurn(planet, <span class="hljs-number">6</span>);
</code></pre>
<p>…и наблюдать за проявлением одного из самых важных свойств объектной иерархии. Грамотное использование этих свойств является основной задачей работы с Xtreme3D. Такого рода проявления можно наблюдать не только в космосе, но и вообще на каждом шагу, поэтому так важно иметь эффективное средство их моделирования.</p>
</body>
</html>

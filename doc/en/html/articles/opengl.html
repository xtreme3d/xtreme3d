<!DOCTYPE html>
<html lang="en">
<head>
    <title>OpenGL</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
</head>
<body>
<h1>OpenGL</h1>

<p>OpenGL (Open Graphics Library) is a specification that defines a cross-platform application programming interface for utilizing using 2D and 3D computer graphics. OpenGL provides functions for drawing complex 3D scenes from simple primitives. It is used to develop computer games, CAD systems, virtual reality applications, and visualization for scientific research. Under Windows, it competes with DirectX.</p>

<h2>Specification</h2>

<p>At its most basic level, OpenGL is simply a specification, a document that describes a set of functions and their exact behavior. Based on this specification, hardware manufacturers create implementations — libraries of functions that correspond to the set of functions in the specification. The implementation uses hardware capabilities where possible. If the hardware does not allow the implementation of a certain feature, it must be emulated in software. Manufacturers must pass specific tests (conformance tests) before the implementation is officially certified. Thus, software developers only need to learn how to use the functions described in the specification, leaving the effective implementation of the latter to hardware developers.</p>

<p>Efficient OpenGL implementations currently exist for Windows, Unix (Linux, BSD, macOS), PlayStation, Android, etc. These implementations are usually provided by graphics card manufacturers and actively use the latter's capabilities. There are also software implementations of OpenGL, one of which is the Mesa library (however, Mesa fully supports hardware acceleration nowadays). Formally, Mesa is an unofficial implementation of OpenGL (it has no certification), although it is fully compatible with the standard.</p>

<p>The original specification was written by Kurt Akeley and Mark Segal. Version 1.1 was edited by Chris Frazier, and versions 1.2 through 2.0 were edited by Jon Leach.</p>

<h2>Architecture</h2>

<p>OpenGL focuses on the following two tasks:</p>
<ul>
<li>hide the hardware differences of 3D accelerators by providing the developer with an abstract graphics API;</li>
<li>hide differences of hardware capabilities by compensating for missing functions using software emulation.</li>
</ul>

<p>The basic principle of OpenGL is obtaining sets of vector graphic primitives (points, lines and polygons), mathematical processing of the obtained data, and rendering a raster image on the screen and/or in memory. Vector transformations and rasterization are performed by a graphics pipeline, which is a discrete automaton. The vast majority of OpenGL commands fall into one of two groups: either they add graphic primitives to the pipeline's input, or they configure the pipeline for different manipulations.</p>

<p>OpenGL is a low-level procedural API, which expects the programmer to describe the exact steps required to build the resulting raster graphics (imperative approach). This is the main difference from declarative approach, when the entire scene is described a data structure, usually a graph, which is processed and rendered on the screen (one example is HTML). On the one hand, the imperative approach requires the programmer to have a deep knowledge of 3D graphics algorithms and mathematical models, on the other hand, it gives much more freedom to implement various innovations.</p>

<h2>Extensions</h2>

<p>With the advent of new technologies, OpenGL allows hardware manufacturers to improve their implementations through the extension mechanism. Extensions are distributed using two components: a header file containing prototypes of new functions and constants, and a device driver supplied by the developer. Each manufacturer has an abbreviation that is used when naming its new functions and constants. For example, NVIDIA has the NV abbreviation, which is used when naming its new functions, such as <code>glCombinerParameterfvNV</code>, and constants: <code>GL_NORMAL_MAP_NV</code>. It may happen that a certain extension can be implemented by several manufacturers. In this case, the EXT abbreviation is used, for example, <code>glDeleteRenderbuffersEXT</code>. In case when an extension is approved by the ARB consortium, it acquires the ARB abbreviation and becomes a standard extension. Typically, extensions approved by the consortium are subsequently included in the core OpenGL specification.</p>

<h2>Utility Libraries</h2>

<p>There are a number of libraries created on top of or in addition to OpenGL. For example, the GLU library, which is almost a standard addition to OpenGL and always accompanies it, is built on top of the latter, that is, it uses its functions to implement its capabilities. Other libraries, such as GLUT and SDL, are created to implement capabilities that are not available in OpenGL. Such capabilities include creating a window, setting up a rendering context, handling input devices like keyboard, mouse and gamepad. Usually, each window manager has its own extension library to implement the above-described capabilities, for example, WGL in Windows or GLX in the X Window System, but the GLUT and SDL libraries are cross-platform, which makes it easier to port applications between platforms. Libraries such as GLEW and GLEE are created to facilitate working with extensions and different versions of OpenGL.</p>

<p>OpenGL supports the simplest set of geometric primitives (points, lines, and polygons), from which all 3D objects are created. Such a low abstraction level is not always convenient when creating games. Therefore, higher-level libraries were created on top of OpenGL, such as GLScene. These libraries allow you to operate with more complex 3D objects, which makes it easier and faster to create a scene.</p>

<h2>Independence from Programming Language</h2>

<p>OpenGL is fully language-independent. It provides a standard C ABI (C-style binary interface), and can be accessed in any language that supports cdecl calling convention and C-style type system. Today, full-featured OpenGL support is available in almost all popular languages, including Java, C#, Python, Perl, Ruby, Lisp, Pascal, Visual Basic, D, etc.</p>

<h2>History</h2>

<p>Today, computer graphics have many applications in everyday life. Scientists use it to analyze the results of modeling. Engineers, designers and architects - to create virtual models of real products. Filmmakers create amazing special effects for movies and cartoons. Game developers take full advantage of hardware rendering to create stunning imaginary worlds.</p>

<p>The spread of computer graphics had its own difficulties. At the dawn of PCs, writing programs that could run on a large number of graphics devices was time-consuming and costly. It was necessary to create modules for each type of graphics adapter separately, which sometimes led to a large duplication of the source code. This greatly slowed down the development and spread of computer graphics.</p>

<p>The history of OpenGL begins back in 1982. It was then that the concept of a graphics state machine was developed at Stanford University, on the basis of which the Silicon Graphics Inc. implemented a rendering pipeline in its Silicon IRIS workstation. SGI specialized in the creation of high-tech graphics hardware and software and was the leader in 3D graphics at that time. As a leader, it more often faced barriers to market growth, caused primarily by the time and financial costs of developing programs capable of running on various graphics hardware. Therefore, it was decided to standardize the way to access graphics hardware at the software interface level. This is how the IRIS GL graphics library was developed, which became the forerunner of OpenGL. One of the limitations of IRIS GL was that it allowed the use of only the capabilities supported by the hardware; if the capability was not implemented in hardware, the application could not use it. In 1992, on the basis of the IRIS GL library, OpenGL graphics standard was developed and approved. OpenGL overcame the problem of its predecessor by implementing software capabilities that were not provided by hardware, which allows applications to use this interface on relatively low-power systems.</p>

<p>At the same time, a consortium of companies supporting the new standard was created, which was called ARB (Architecture Review Board). It has been determining the development of this graphic API for many years, revising its specifications as needed. In addition to SGI, ARB included many large corporations, such as IBM, Intel, Sun Microsystems, DEC, Evans &amp Sutherland, Hewlett-Packard and Intergraph. Even Microsoft had a hand in the new graphic standard - the same Microsoft that a few years later, in 1995, would release the first version of DirectX, the future main competitor of OpenGL. Microsoft left ARB in 2003, but now the consortium includes all major video card manufacturers, including AMD and NVIDIA.</p>

<p>Originally created for the professional sector, OpenGL has become very firmly established there. It was used on high-performance workstations, in the scientific field, in education, and in projects that required portability of applications across various hardware platforms. By the time ARB turned its attention to the rapidly developing gaming sector, it turned out that OpenGL had serious competitors. The gaming graphics accelerator market was dominated by 3DFX, which created the first full-fledged API for gaming needs in 1994 - Glide. Naturally, it supported only cards manufactured by the company itself, which allowed it to become a virtual monopolist in the gaming 3D market for several years. The closed nature of the API played a cruel joke on 3DFX - when OpenGL appeared on the gaming market in 1996, it was greeted with open arms. However, it was not able to create worthy competition at first - games were still written for Glide.</p>

<p>Meanwhile, OpenGL had another rival — Microsoft took up the development of an API that would belong only to it. In 1995, the company released the first version of DirectX, then called Games SDK and working only under Windows. However, an OpenGL port for Windows also existed, but it worked much worse and slower than the "native" Direct3D. This happened not because of the advantage of the Microsoft's API, but for political reasons. The port, implemented by Microsoft, worked through the slow software port MCD, and not through the fast ICD (Installable Client Driver). This was done, of course, with the aim that game developers would work with Direct3D, and not with OpenGL, which was inferior to it in performance. At first it was so, but soon an ICD port developed by SGI appeared, and then many graphics card manufacturers began to include their own versions of ICD ports in the driver kit, allowing the most efficient use of all the acceleration capabilities provided by a particular card. In addition, manufacturers could freely add new functions not provided by OpenGL to the ICD ports, which provided an expansion of OpenGL functionality. Feeling that it was losing control, Microsoft decided to stop the standards war and suggested to develop a single API. The project was called Fahrenheit, and the work began. In the meantime, Microsoft demanded that all references to the SGI implementation of OpenGL be removed from the Internet and that its further support be stopped, which was done. Alas, the Fahrenheit API was not destined to see the light of day. Microsoft, pursuing its own benefits, decided to implement the new API only through Direct3D, and the cooperation did not work out. SGI was responsible for the OpenGL part of the project, but the company was going through hard times, employees were leaving for NVIDIA, so SGI representatives were not enthusiastic. So OpenGL would have died quietly and unnoticed, if it had not received strong support from John Carmack. id Software chose OpenGL as the primary graphics API for their game Quake II, which was the salvation for the latter. The game was a great success, modifications and sequels soon began to appear. The id Tech 2 engine became popular and was licensed by third-party developers. OpenGL survived, and the big race continued.</p>

<p>It has been said that the main problem with OpenGL, compared to DirectX, was the consortium, which included a large number of companies with different interests, which led to a long periods of adoption of new versions of the specification. OpenGL version 2.0 was introduced by 3DLabs in response to concerns about the slow development and unclear direction of OpenGL. 3DLabs proposed a number of significant additions to the standard, the most significant of which was the addition of the GLSL (OpenGL Shading Language) to the core API. It allowed the programmer to replace the fixed pipeline with programs written in a high-level language to create various effects such as bump mapping, parallax mapping, HDR, etc. GLSL support was included in the final version of the OpenGL 2.0 specification, but even before that it was possible to develop special effects in low-level assembly-like language (via GL_ARG_vertex_program and GL_ARB_fragment_program extensions) and Cg (C for Graphics), a high-level language created by NVIDIA.</p>

<p>On July 31, 2006, at SIGGRAPH, it was announced that control of the OpenGL specification would be transferred to the Khronos Group, a group of companies involved in creating multimedia technology standards. In addition to OpenGL, the Khronos Group manages such standards as OpenCL, OpenVG, COLLADA, and many others.</p>

<p>In 2008, the Khronos Group released the OpenGL 3.0 specification, which included support for GLSL 1.3, Vertex Array Objects, texture arrays, more flexible FBOs, and a number of other graphics features. What OpenGL 3.0 did not include was the major API overhaul that many developers had been expecting, and which did not become available until many months later.</p>

<p>On March 24, 2009, Khronos Group announced OpenGL 3.1. This version cleaned up components that were deprecated but remained in OpenGL 3.0 to smooth the transition to the new API (deprecated components could still be used through the GL_ARB_compatibility extension). OpenGL 3.1 also added a number of new features, such as support for GLSL version 1.4, copy buffer, texture buffer objects, etc.</p>

<p>On March 11, 2010, the ARB approved the OpenGL 4.0 specification. Among the new features are expanded integration with OpenCL (Open Computing Language), multi-threaded rendering, an update to GLSL version 4.0, support for 64-bit floating point operations, and numerous performance improvements.</p>

<p>OpenGL 4.1 was released on July 26, 2010. The specification included an update to GLSL to version 4.10, as well as support for saving and loading binary compiled versions of shader programs.</p>

<p>On August 9, 2011, the Khronos Group released OpenGL 4.2 and the GLSL 4.20 shader description language.</p>

<p>In 2012, Khronos Group celebrated OpenGL's 20th anniversary by releasing OpenGL 4.3. This version debuted compute shaders, which allow the GPU to be used for non-graphics tasks, as well as buffer data objects that can be passed between shaders.</p>

<p>In 2013, OpenGL 4.4 was introduced, which included tools for working with video memory, support for asynchrony, and tools to simplify porting applications with Direct3D 11.</p>

<p>OpenGL 4.5, released in 2014, supports a new method for accessing the state of objects in video memory, allowing state to be interrogated and changed without tying objects to contexts.</p>

<p>In 2017, OpenGL 4.6 was released, which introduced support for SPIR-V, an intermediate representation of shaders, as well as anisotropic texture filtering.</p>

<p>The big race has been going on for over 25 years, and how long it will last is unknown. But OpenGL, despite constantly lagging behind by half a step, stubbornly does not leave the race. Openness, independence from hardware and programming language, cross-platform and extension mechanisms are what have kept it afloat all these years. Even the emergence of Vulkan, a next-generation graphics API, in 2015 did not shake OpenGL's position, as it is used not only on the desktop, but also on mobile platforms (OpenGL ES) and in web applications (WebGL).</p>
</body>
</html>

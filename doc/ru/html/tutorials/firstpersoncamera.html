<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Tutorial 4. First person camera</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="4">Урок 4. Камера от первого лица</h1>
<p>На уроке 3 мы рассмотрели простейший вариант камеры от первого лица - она управлялась клавишами-стрелками. Между тем, в абсолютном большинстве современных игр в этом случае используется управление мышью. Давайте рассмотрим, как реализовать его средствами Xtreme3D.</p>
<p>Начнем с того, что создадим родительский Манекен для камеры - camPos. Мы будем двигать не камеру, а его.</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">camPos = DummycubeCreate(<span class="hljs-symbol">global</span>.scene);
ObjectSetPosition(camPos, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>);
camera = CameraCreate(camPos);
ViewerSetCamera(view1, camera);
</code></pre>
<p>Дело в том, что камера должна двигаться только в плоскости XZ - иными словами, не должна "летать" по воздуху. Мы будем поворачивать объект camPos по оси Y, когда пользователь сместит мышь по горизонтали - таким образом, можно будет управлять направлением движения. Смещение мыши по вертикали вызовет локальный поворот объекта camera по оси X - таким образом, пользователь сможет смотреть вверх и вниз, но это никак не повлияет на направление движения, ведь camera наследует движение от camPos.</p>
<p>Объявим также следующие переменные:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">centerX = <span class="hljs-built_in">display_get_width</span>() / <span class="hljs-number">2</span>;
centerY = <span class="hljs-built_in">display_get_height</span>() / <span class="hljs-number">2</span>;
</code></pre>
<p>Это координаты центра экрана. Мы будем считывать смещение мыши относительно этой точки, а затем возвращать в нее курсор.</p>
<p>Можно также сразу поместить курсор в центр экрана, чтобы на начало игры камера смотрела строго вперед:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml"><span class="hljs-built_in">display_mouse_set</span>(centerX, centerY);
</code></pre>
<p>Теперь переходим к событию Step. Следующий код вычисляет смещение курсора мыши относительно центра экрана и поворачивает camPos и camera на соответствующие углы, deltaX и deltaY: </p>
<pre class="gml language-gml"><code class="hljs gml language-gml">deltaX = (centerX - <span class="hljs-built_in">display_mouse_get_x</span>()) / <span class="hljs-number">3</span>;
deltaY = (centerY - <span class="hljs-built_in">display_mouse_get_y</span>()) / <span class="hljs-number">3</span>;
ObjectRotate(camera, deltaY, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
ObjectRotate(camPos, <span class="hljs-number">0</span>, -deltaX, <span class="hljs-number">0</span>);
<span class="hljs-built_in">display_mouse_set</span>(centerX, centerY);
</code></pre>
<p>Осталось реализовать движение. Мы будем использовать стандартную для игр от первого лица раскладку WASD: </p>
<pre class="gml language-gml"><code class="hljs gml language-gml">dt = <span class="hljs-number">1.0</span> / <span class="hljs-variable language_">room_speed</span>;
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;W&#x27;</span>)) ObjectMove(camPos, <span class="hljs-number">-10</span> * dt);
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;A&#x27;</span>)) ObjectStrafe(camPos, <span class="hljs-number">10</span> * dt);
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;D&#x27;</span>)) ObjectStrafe(camPos, <span class="hljs-number">-10</span> * dt);
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-built_in">ord</span>(<span class="hljs-string">&#x27;S&#x27;</span>)) ObjectMove(camPos, <span class="hljs-number">10</span> * dt);
</code></pre>
<p>Смысл умножения на dt в следующем. Если двигать объекты с фиксированной скоростью, их фактическая скорость движения будет привязана к кадровой частоте приложения. То есть, например, если мы двигаем объект на 10 единиц за кадр, скорость при частоте в 60 FPS будет равняться 10 * 60 = 600 единицам в секунду. При частоте 120 FPS, соответственно - 10 * 120 = 1200. В итоге, объект будет двигаться быстрее или медленнее, в зависимости от FPS. Это совсем не то, что нам нужно, поэтому нужно задавать скорость в других величинах, не привязанных к кадру. Например - в единицах в секунду. Следовательно, кадровая скорость будет равна V / FPS, где V - скорость. Мы просто выясняем, на сколько объект должен переместиться за один кадр, если в секунду он перемещается на V единиц. Таким образом, объект будет двигаться с правильной скоростью при любой кадровой частоте.</p>
<p>Чтобы не загромождать код делениями (деление, как известно, относительно медленная операция), мы вместо этого умножаем скорость на 1 / FPS - это значение можно рассчитать только один раз. Оно также называется шагом времени (именно этот шаг времени следует передавать в функцию Update, о чем говорилось на уроке 2). В Game Maker 8 кадровая частота (FPS) обычно фиксирована и задается в настройках комнаты (Room speed). Ее можно выставить равной 60 или 120.</p>
</body>
</html>

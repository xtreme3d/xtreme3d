<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Tutorial 10. Third person camera</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="10">Урок 10. Камера от третьего лица</h1>
<p>Многие игры используют вид от третьего лица, где камера показывает персонажа "со спины" - это, например, многие игры жанров Action и RPG, 3D-платформеры типа Spyro или Crash Bandicoot, спортивные симуляторы и т.д. При этом, как правило, камера не является жестко зафиксированной на определенном расстоянии от персонажа - она обычно перемещается плавно, с некоторым запаздыванием, что добавляет реализма и кинематографичности.</p>
<p>На Xtreme3D подобную механику реализовать ненамного сложнее, чем вид от первого лица. Нижеследующий код создаст иерархию из персонажа, которым игрок будет управлять, и камеры, которая будет за ним следить. В качестве условного персонажа используется простой куб.</p>
<p>Код в событии Create:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">camera = CameraCreate(<span class="hljs-symbol">global</span>.scene);
CameraSetViewDepth(camera, <span class="hljs-number">800</span>);
CameraSetFocal(camera, <span class="hljs-number">80</span>);
ViewerSetCamera(view1, camera);

actor = CubeCreate(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-symbol">global</span>.scene);

target = DummycubeCreate(actor);
ObjectSetPosition(target, <span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">-4</span>);
CameraSetTargetObject(camera, actor);
</code></pre>
<p>Код в событии Step:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml"><span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-symbol">vk_up</span>) ObjectMove(actor, <span class="hljs-number">10</span> * dt)
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-symbol">vk_down</span>) ObjectMove(actor, <span class="hljs-number">-10</span> * dt);
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-symbol">vk_left</span>) ObjectTurn(actor, <span class="hljs-number">-200</span> * dt);
<span class="hljs-keyword">if</span> <span class="hljs-built_in">keyboard_check</span>(<span class="hljs-symbol">vk_right</span>) ObjectTurn(actor, <span class="hljs-number">200</span> * dt);

cx = ObjectGetAbsolutePosition(camera, <span class="hljs-number">0</span>);
cy = ObjectGetAbsolutePosition(camera, <span class="hljs-number">1</span>);
cz = ObjectGetAbsolutePosition(camera, <span class="hljs-number">2</span>);
tx = ObjectGetAbsolutePosition(target, <span class="hljs-number">0</span>);
ty = ObjectGetAbsolutePosition(target, <span class="hljs-number">1</span>);
tz = ObjectGetAbsolutePosition(target, <span class="hljs-number">2</span>);
dx = tx - cx;
dy = ty - cy;
dz = tz - cz;
ObjectTranslate(camera, dx * <span class="hljs-number">0.05</span>, dy * <span class="hljs-number">0.05</span>, dz * <span class="hljs-number">0.05</span>);
</code></pre>
<p>Логика камеры устроена так, что ее наиболее дальняя дистанция от персонажа - при движении вперед (чтобы можно было хорошо видеть, что творится вокруг), а самая близкая - при движении назад. При повороте персонажа камера позволяет рассмотреть его сбоку. Примерно такой же прием используется в гоночных симуляторах, так что на основе этого кода вполне можно сделать и движок гонок.</p>
</body>
</html>

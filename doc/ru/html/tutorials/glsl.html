<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Tutorial 19. GLSL</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="19glsl">Урок 19. Основы GLSL</h1>
<p>GLSL (OpenGL Shading Language) - это высокоуровневый язык описания шейдеров. С его помощью вы можете запрограммировать графический конвейер - иными словами, управлять рендерингом объектов на вершинном и пиксельном уровне. За обработку вершин отвечает вершинная программа GLSL, за обработку пикселей - фрагментная.</p>
<p>Работа с GLSL подразумевает знание принципов растеризации и графического конвейера OpenGL, а также линейной алгебры. Поскольку сам Xtreme3D не требует этих знаний, использование GLSL может быть весьма трудной задачей для начинающего, поэтому рекомендуем предварительно почитать книги или руководства по данной теме. Очень полезным будет знакомство с принципами работы в OpenGL, а также хотя бы базовое знание C/C++.</p>
<h2 id="glsl">Типы данных GLSL</h2>
<p>GLSL является строго типизированным языком - любая переменная в нем имеет определенный тип. Язык поддерживает следующие основные типы:</p>
<p><code>bool</code> - логическое значение<br>
<code>int</code> - целое число со знаком<br>
<code>uint</code> - беззнаковое целое число<br>
<code>float</code> - число с плавающей запятой одинарной точности<br>
<code>double</code> - число с плавающей запятой двойной точности<br>
<code>bvec2</code>, <code>bvec3</code>, <code>bvec4</code> - вектор логических значений (размерности 2, 3 и 4)<br>
<code>ivec2</code>, <code>ivec3</code>, <code>ivec4</code> - вектор целых чисел<br>
<code>uvec2</code>, <code>uvec3</code>, <code>uvec4</code> - вектор беззнаковых целых чисел<br>
<code>vec2</code>, <code>vec3</code>, <code>vec4</code> - вектор чисел с плавающей запятой<br>
<code>dvecn2</code>, <code>dvecn3</code>, <code>dvecn4</code> - вектор чисел с плавающей запятой двойной точности<br>
<code>mat2</code>, <code>mat3</code>, <code>mat4</code> - матрица 2x2, 3x3, 4x4<br>
<code>sampler2D</code> - текстура<br>
<code>sampler2DCube</code> - кубическая текстура<br>
<code>sampler2DShadow</code> - теневая текстура<br>
<code>void</code> - ключевое слово, обозначающее отсутствие типа (для функций без возвращаемого результата).</p>
<h2 id="">Вершинный шейдер</h2>
<p>Вершинная программа принимает координаты вершин и их атрибуты (такие как нормали и тангенты) и, как правило, переводит их из объектного пространства в пространство отсечения, в мировое или в видовое пространство.</p>
<ul>
<li>Объектное пространство (object space) - это локальное пространство объекта. Центром координатной системы в нем является центр объекта - вершины модели заданы относительно этого центра.</li>
<li>Мировое пространство (world space) - другое название для абсолютного пространства. Центром координатной системы в нем является точка (0, 0, 0). Совокупная трансформация объекта (перенос, поворот и масштабирование) переводит вершины из локального в мировое пространство. Эта трансформация обычно хранится и передается в шейдер в виде матрицы 4x4 - так называемой модельной матрицы (model matrix).</li>
<li>Видовое пространство (eye space) - пространство, в котором центром координатной системы является позиция камеры. Перевод вершин из мирового в видовое пространство осуществляется при помощи обратной матрицы преобразования камеры - так называемой видовой матрицы (view matrix). В OpenGL, как правило, модельная матрица и видовая совмещены в одну - модельно-видовую (modelview matrix).</li>
<li>Пространство отсечения (clip space) - пространство, в которое вершины переводятся матрицей проекции (projection matrix).
Необходимо отметить, что вершины в GLSL хранятся в так называемых однородных координатах (homogeneous coordinates) - то есть, имеют дополнительную четвертую координату W. Такими координатами можно выражать бесконечно удаленные точки, когда W равна нулю. Обычные точки имеют W равную 1.</li>
</ul>
<p>Вершины в пространстве отсечения являются главным результатом работы вершинного шейдера. Простейший вершинный шейдер, выполняющий только перевод вершин из объектного пространства в пространство отсечения, выглядит следующим образом:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-type">void</span> main()
{
   <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">gl_ModelViewProjectionMatrix</span> * <span class="hljs-built_in">gl_Vertex</span>;
}
</code></pre>
<p><code>gl_Vertex</code> - входные координаты вершины<br>
<code>gl_Position</code> - выходные координаты вершины<br>
<code>gl_ModelViewProjectionMatrix</code> - встроенная матрица 4х4, комбинация модельно-видовой и проекционной матриц OpenGL.</p>
<p>Для данной операции, кстати, в GLSL имеется встроенная функция <code>ftransform</code>:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();
</code></pre>
<p>Вершинному шейдеру также доступны другие атрибуты вершины - нормаль, цвет и текстурные координаты: <code>gl_Normal</code>, <code>gl_Color</code>, <code>gl_MultiTexCoordN</code> (где N - номер от 0 до 7). Обычно эти атрибуты интерполируются между тремя вершинами треугольника, а затем поступают во фрагментный шейдер. Чтобы передать какое-либо значение на интерполяцию, используются промежуточные varying-переменные. Например, так выглядит шейдер, передающий на интерполяцию нормали:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> normal;

<span class="hljs-type">void</span> main() 
{
    normal = <span class="hljs-built_in">gl_NormalMatrix</span> * <span class="hljs-built_in">gl_Normal</span>;
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();
}
</code></pre>
<p>Обратите внимание, что мы переводим нормаль вершины из объектного пространства в видовое при помощи специальной встроенной матрицы 3x3 <code>gl_NormalMatrix</code>. Это необходимо для того, чтобы оптимальным образом рассчитывать освещение в пиксельном шейдере - это делается именно в видовом пространстве: тот факт, что камера находится в точке (0,0,0), значительно облегчает вычисления, связанные с бликовой компонентой освещенности.</p>
<p>С передачей текстурных координат шейдер будет выглядеть так: </p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> normal;

<span class="hljs-type">void</span> main()
{
    normal = <span class="hljs-built_in">gl_NormalMatrix</span> * <span class="hljs-built_in">gl_Normal</span>;
    <span class="hljs-built_in">gl_TexCoord</span>[<span class="hljs-number">0</span>] = <span class="hljs-built_in">gl_MultiTexCoord0</span>;
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();
}
</code></pre>
<p><code>gl_TexCoord</code> - это встроенная varying-переменная, массив, через который вы можете передавать любые данные, не только текстурные координаты.</p>
<h2 id="-1">Фрагментный шейдер</h2>
<p>Фрагментная программа принимает интерполированные varying-переменные (а также различные параметры состояния OpenGL) и выводит в качестве результата цвет пикселя. Она выполняется для каждого видимого на экране пикселя объекта. Обратите внимание, что проверка видимости (Z-test) для пикселя осуществляется видеокартой до того, как будет выполнена фрагментная программа - если пиксель отбрасывается как невидимый, то программа не выполняется.</p>
<p>Простейший фрагментный шейдер, закрашивающий объект сплошным цветом, выглядит так:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-type">void</span> main()
{
    <span class="hljs-built_in">gl_FragColor</span> = <span class="hljs-type">vec4</span>(<span class="hljs-number">1.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
}
</code></pre>
<p><code>gl_FragColor</code> - выходной цвет пикселя.</p>
<p>В данном случае <code>vec4(1.0, 0.0, 0.0, 1.0)</code> обозначает красный цвет с прозрачностью 1.0 (полная непрозрачность).</p>
<h2 id="xtreme3d">Использование шейдеров в Xtreme3D</h2>
<p>Создавать шейдеры GLSL и подключать их к материалам очень просто:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">vp = TextRead(<span class="hljs-string">&quot;my_vertex_shader.glsl&quot;</span>);
fp = TextRead(<span class="hljs-string">&quot;my_fragment_shader.glsl&quot;</span>);
shader = GLSLShaderCreate(vp, fp);
MaterialSetShader(<span class="hljs-string">&quot;myMaterial&quot;</span>, shader);
</code></pre>
<h2 id="glsl-1">Освещение на GLSL</h2>
<p>Чтобы реализовать простейшее освещение по формуле Ламберта, нам нужны координаты точки поверхности, нормаль в этой точке, а также координаты источника света. Таким образом, нам понадобятся, по меньшей мере, две varying-переменные - нормаль и интерполированные координаты вершины.</p>
<p>Вершинный шейдер:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> normal;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> position;

<span class="hljs-type">void</span> main() 
{
    normal = <span class="hljs-built_in">gl_NormalMatrix</span> * <span class="hljs-built_in">gl_Normal</span>;
    position = (<span class="hljs-built_in">gl_ModelViewMatrix</span> * <span class="hljs-built_in">gl_Vertex</span>).xyz;
    <span class="hljs-built_in">gl_Position</span> = <span class="hljs-built_in">ftransform</span>();
}
</code></pre>
<p><code>gl_ModelViewMatrix</code> - это встроенная матрица 4x4, модельно-видовая матрица OpenGL. Она переводит координаты из объектного пространства в видовое, в котором мы будем вычислять освещение. Поскольку результат этого перевода - однородный вектор vec4, мы отбрасываем координату W и берем только вектор XYZ.</p>
<p>Фрагментный шейдер:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> normal;
<span class="hljs-keyword">varying</span> <span class="hljs-type">vec3</span> position;

<span class="hljs-type">void</span> main() 
{
    <span class="hljs-type">vec3</span> N = <span class="hljs-built_in">normalize</span>(normal);
    <span class="hljs-type">vec3</span> L = <span class="hljs-built_in">normalize</span>(<span class="hljs-built_in">gl_LightSource</span>[<span class="hljs-number">0</span>].position.xyz - position);
    <span class="hljs-type">float</span> diffuse = <span class="hljs-built_in">clamp</span>(<span class="hljs-built_in">dot</span>(N, L), <span class="hljs-number">0.0</span>, <span class="hljs-number">1.0</span>);
    <span class="hljs-type">vec4</span> color = <span class="hljs-built_in">gl_FrontMaterial</span>.diffuse * diffuse;
    color.a = <span class="hljs-number">1.0</span>;
    <span class="hljs-built_in">gl_FragColor</span> = color;
}
</code></pre>
<p>Обратите внимание, что при передаче во фрагментый щейдер единичные векторы (такие, как нормаль) после интерполяции нужно обязательно нормировать - видеокарта не делает это за вас. Для этого в GLSL есть функция <code>normalize</code>.</p>
<p>Доступ к координатам источника света осуществляется при помощи атрибута position встроенного объекта <code>gl_LightSource</code> (массив из 8 элементов, по числу источников света OpenGL). Эти координаты во фрагментном шейдере уже автоматически переведены в видовое пространство, что очень удобно - не нужно делать это вручную. Но если вам, по тем или иным причинам, нужно вычислять освещение в другом пространстве - например, в пространстве касательных - то не забудьте соответствующим образом трансформировать их. Эти координаты также однородные: точечный источник света, как правило, имеет координату W равную 1, направленный - равную 0.</p>
<p>Операция <code>dot(N, L)</code> - это и есть расчет освещенности по формуле Ламберта: освещенность в точке определяется плотностью света, а она линейно зависит от косинуса угла падения света. Косинус угла между двумя единичными векторами равен их скалярному произведению (dot product).</p>
<p>Поскольку результат этой операции - скаляр (<code>float</code>), для передачи в <code>gl_FragColor</code> нужно помножить это значение на какой-нибудь цвет. Лучше всего использовать диффузный цвет материала - <code>gl_FrontMaterial.diffuse</code>: таким образом, вы можете контролировать цвет объекта вне шейдера, функцией <code>MaterialSetDiffuseColor</code>.</p>
<h2 id="-2">Текстуры</h2>
<p>Во фрагментном шейдере можно читать цвет из текстур - для этого используется функция texture2D:</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-keyword">uniform</span> <span class="hljs-type">sampler2D</span> diffuseTexture;

<span class="hljs-type">void</span> main()
{
    <span class="hljs-type">vec4</span> texColor = <span class="hljs-built_in">texture2D</span>(diffuseTexture, <span class="hljs-built_in">gl_TexCoord</span>[<span class="hljs-number">0</span>].xy);
    <span class="hljs-built_in">gl_FragColor</span> = texColor;
}
</code></pre>
<p>Текстуры объявляются как uniform-объекты - то есть, неизменяемые параметры, которые передаются шейдеру основной программой. Это могут быть не только текстуры, но и вообще любые типы данных.</p>
<p>Передача текстуры в шейдер делается следующим образом:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">param = GLSLShaderCreateParameter(shader, <span class="hljs-string">&quot;diffuseTexture&quot;</span>);
GLSLShaderSetParameterTexture(param, <span class="hljs-string">&quot;myMaterial&quot;</span>, <span class="hljs-number">0</span>);
</code></pre>
<p>В функцию GLSLShaderCreateParameter передается имя uniform-объекта. В функцию <code>GLSLShaderSetParameterTexture</code> передается имя материала, из которого нужно прочитать текстуру, а также текстурный блок, через который нужно передавать текстуру. Стандарт OpenGL гаранирует 8 доступных текстурных блоков (0-7) - у современных видеокарт их может быть и больше (до 16 и даже 32), но для лучшей совместимости рекомендуется не использовать больше 8. В одном шейдере нельзя передавать две разные текстуры через один и тот же текстурный блок - то есть, если вы передаете несколько текстур в разные uniform-параметры, используйте для них разные блоки.</p>
<h2 id="glsl-2">О версиях GLSL</h2>
<p>Xtreme3D базируется на OpenGL 1.x и некоторых функциях из OpenGL 2.х, которые подключаются через расширения ARB. Таким образом, движок поддерживает GLSL версий 1.1 и 1.2 - более поздние версии языка определены уже в рамках спецификации OpenGL 3.0.</p>
<p>По умолчанию используется GLSL 1.1. Чтобы переключиться на 1.2, используйте директиву препроцессора (на первой строке шейдера):</p>
<pre class="glsl language-glsl"><code class="hljs glsl language-glsl"><span class="hljs-meta">#version 120</span>
</code></pre>
<p>Версия 1.2 отличается встроенной поддержкой транспонирования матриц (функция <code>transpose</code>), неквадратных матриц, а также массивов.</p>
</body>
</html>

<HTML>
<HEAD>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<TITLE>Иерархия объектов</TITLE>
<LINK href="../data/style.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>

<DIV ALIGN=justify>

<H1 class=pagetitle>Урок 3<BR>Иерархия объектов</H1>

<A><B>Уровень:</B> начинающий</A>
<BR><A><B>Версия Xtreme3D:</B> 3.0.x</A>
<BR><A><B>Автор урока:</B> Gecko</A><A class=ntext>
<BR>
<BR>Понятие иерархии нам уже встречалось, но до сих мы не рассматривали ее на практике. Многие, кто не знаком с 
данным подходом организации объектов, и не подозревают, о какой громадной экономии сил и времени здесь идет речь. 
Иерархия позволяет безо всякого труда сделать то, что слишком тяжело или вообще невозможно без ее использования. 
Дело касается специфики перемещений объектов в некоторых особых случаях.
<BR>
<BR>Представьте себе, к примеру, такую ситуацию: необходимо смоделировать простейшую звездную систему - солнце 
и вращающуюся вокруг нее планету. Вокруг планеты, в свою очередь, вращается спутник. Для простоты будем пока 
мыслить в двумерном пространстве. Как можно поступить?
<BR>
<BR>Пусть Sun - солнце, Planet - планета, Moon - спутник. У каждого объекта есть две координаты - X и Y, а также 
угол вращения вокруг своей оси - A. Тогда (в псевдокоде)
<BR>
<BR><A>Sun.X = 0</A>
<BR><A>Sun.Y = 0</A>
<BR><A>Planet.X = Sun.X + cos(Sun.A) * 10</A>
<BR><A>Planet.Y = Sun.Y + sin(Sun.A) * 10</A>
<BR>
<BR>Принимая во внимание, что расстояние между солнцем и планетой равно 10 условным единицам. При повороте 
солнца вокруг своей оси, планета будет вращаться вокруг нее, перемещаясь на координаты, вычисленные из угла 
поворота солнца и искомого расстояния. Нетрудно теперь аналогично рассчитать и координаты спутника:
<BR>
<BR><A>Moon.X = Planet.X + cos(Planet.A) * 2</A>
<BR><A>Moon.Y = Planet.Y + sin(Planet.A) * 2</A>
<BR>
<BR>Но вручную это делать не всегда удобно. Особенно, если в системе не три объекта, а, скажем, все десять. 
Или расположение объектов периодически меняется (например, спутник отрывается от одной планеты и переходит к 
другой). Разумнее будет автоматизировать процесс, введя для каждого объекта свойство родителя (Parent):
<BR>
<BR><A>Planet.Parent = Sun</A>
<BR><A>Moon.Parent = Planet</A>
<BR>
<BR>И обновлять координаты объектов одинаковой для всех формулой:
<BR>
<BR>Object.X = Object.Parent.X + cos(Object.Parent.A) * 2</A>
<BR>Object.Y = Object.Parent.Y + sin(Object.Parent.A) * 2</A>
<BR>
<BR>Так и реализуется простейшая иерархия. 
<BR>
<BR>С двумерной графикой все относительно просто. Но как быть с трехмерной? В трехмерной графике вдобавок к 
синусам и косинусам используются векторы и матрицы. Операции с ними довольно ресурсоемки и чрезвычайно сложны 
для осмысления новичком. К тому же, слишком часто осуществлять такие операции на уровне GML нерационально: 
для хранения массивов под матрицы потребуется больше памяти, а математические операции с ними снизят FPS. 
Но не все так ужасно. Xtreme3D берет на себя все ресурсоемкие вычисления, исполняя их на уровне машинного кода, 
поэтому ее иерархия будет работать гораздо быстрее и точнее, чем написанная вручную на GML.
<BR>
<BR>При использовании встроенной иерархии Xtreme3D вся работа сводится к указанию родителей для объектов. 
Весь фокус в том, что потомок наследует координатную систему родителя. Например, координаты родителя (X, Y, Z) 
становятся координатами центра, относительно которого ведется отсчет собственных координат его потомка 
(X+x, Y+y, Z+z). Потомок, в свою очередь, передает собственные координаты своим потомкам, и так далее. 
Собственные координаты объекта называются локальными.
<BR>
<BR>Координатная система может быть трансформирована перемещением, поворотом или масштабированием. Поворот 
локальной координатной системы родителя вызывает изменение направления осей в унаследованной координатной 
системе потомка, что автоматически приводит к его вращению в пространстве. Если в момент вращения потомок 
был на некотором расстоянии от центра унаследованной им системы координат, это будет выглядеть, как вращение 
потомка вокруг своего родителя. Совсем как в нашем примере!
<BR>
<BR>Для создания системы с солнцем и планетами в нашем случае достаточно написать что-то вроде этого:
<BR>
<BR><A>sun=</A><A class=func2link href=../functions/primitives.htm#SphereCreate>SphereCreate</A><A>(4, 24, 24, <B>global</B>.scene);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectSetPosition>ObjectSetPosition</A><A>(sun, 0, 0, 0);</A>
<BR><A>planet=</A><A class=func2link href=../functions/primitives.htm#SphereCreate>SphereCreate</A><A>(1, 24, 24, sun);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectSetPosition>ObjectSetPosition</A><A>(planet, 0, 0, 10);</A>
<BR><A>moon=</A><A class=func2link href=../functions/primitives.htm#SphereCreate>SphereCreate</A><A>(0.5, 24, 24, planet);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectSetPosition>ObjectSetPosition</A><A>(moon, 0, 0, 2);</A>
<BR>
<BR>Функция <A class=func2link href=../functions/primitives.htm#SphereCreate>SphereCreate</A> создает сферу. 
Необходимо указать ее радиус, а также количество меридиан и параллелей. У нашего солнца радиус равен 4, у 
планеты — 1, у спутника — 0.5. Меридианы и параллели (slices, stacks) делят сферу на квадраты, количество 
которых задает качество внешнего вида сферы. Обычно достаточно указать 24 меридиана и 24 параллели.
<BR>Теперь можно в событии Step поворачивать солнце и планету:
<BR>
<BR><A class=func2link href=../functions/object.htm#ObjectTurn>ObjectTurn</A><A>(sun, 2);</A>
<BR><A class=func2link href=../functions/object.htm#ObjectTurn>ObjectTurn</A><A>(planet ,6);</A>
<BR>
<BR>...И наблюдать за проявлением одного из самых важных свойств объектной иерархии. 
Грамотное использование этих свойств является основной задачей работы с Xtreme3D. Такого рода 
проявления можно наблюдать не только в космосе, но и вообще на каждом шагу, поэтому так важно иметь эффективное 
средство их моделирования.
</A>

</DIV>

</BODY>
</HTML>

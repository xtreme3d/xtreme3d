<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Tutorial 18. Shaders</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="18">Урок 18. Шейдеры</h1>
<p>Одной из самых интересных особенностей Xtreme3D является поддержка шейдеров. Понятие "шейдер" здесь имеет более широкое значение, чем в других движках. Обычно этим термином обозначают программы для графического процессора, которые выполняются для каждой вершины модели, либо для каждого пикселя модели на экране. Такие шейдеры в Xtreme3D тоже есть (см. следующий урок), но в общем смысле шейдером называется спецэффект, модифицирующий или заменяющий собой материал, к которому он прикреплен. Некоторые такие спецэффекты работают и на старых видеокартах, которые не поддерживают шейдерные программы, а некоторые основаны на встроенных в движок программах.</p>
<p>При помощи шейдеров можно наложить на объект несколько материалов, отрисовать контуры объекта, сделать объект рельефным или придать ему "эффект комикса". Рассмотреть все возможности встроенных шейдеров Xtreme3D в рамках одного урока невозможно, поэтому мы остановимся на одном - шейдере рельефа (Bump Shader).</p>
<p>Эффект рельефности сильно повышает реализм моделей - он используется в играх уже более 10 лет и за эти годы стал де-факто стандартом. Обычно рельефность достигается путем использования метода normal mapping (проецирование нормалей). На этом методе основан и Bump Shader в Xtreme3D. Суть normal mapping в том, что нормаль задается для каждой точки поверхности (в отличие от обычного вершинного освещения, где нормали задаются для каждой вершины, а затем просто интерполируются по поверхности полигона). Это делается при помощи карты нормалей (normal map) - специальной текстуры, в которой цвета пикселей сопоставлены с векторами нормалей (RGB = XYZ). Карту нормалей можно сгенерировать из карты высот или из высокополигональной геометрии путем трассировки лучей - такая функция есть практически во всех профессиональных пакетах 3D-моделирования.</p>
<p><img src="../data/normalmap.jpg" alt="normalmap" /></p>
<p>Чтобы карта нормалей была инвариантна относительно вращения и переноса модели (то есть, оставалась неизменной при этих трансформациях), ее задают в особом пространстве, называемом пространством касательных (tangent space). В этом пространстве координатная ось Z соответствует перпендикуляру к поверхности, а оси X и Y, соответственно, взаимно перпендикулярным касательным к поверхности. Освещение также рассчитывается в пространстве касательных - направление света трансформируется в это пространство при помощи специальной матрицы, которую называют TBN по первым буквам ее компонентов - Tangent, Binormal, Normal (тангент, бинормаль, нормаль). Нормаль здесь - обычная нормаль вершины, а тангент и бинормаль - векторы, перпендикулярные нормали и перпендикулярные друг другу. Эти векторы вычисляет Xtreme3D. В настоящее время они поддерживаются только для объектов типа Freeform.</p>
<p>Несмотря на довольно сложную для начинающих теоретическую базу, использовать эффект рельефа в Xtreme3D очень легко - все сложности реализации скрыты под удобным API.</p>
<p>Сначала создадим материалы с необходимыми текстурами:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">MaterialCreate(<span class="hljs-string">&quot;mBumpDiffuse&quot;</span>, <span class="hljs-string">&quot;diffuse.png&quot;</span>);
MaterialCreate(<span class="hljs-string">&quot;mBumpNormal&quot;</span>, <span class="hljs-string">&quot;normal.png&quot;</span>);
</code></pre>
<p>Теперь создадим шейдер рельефа и передадим ему текстуры:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">bump = BumpShaderCreate();
BumpShaderSetDiffuseTexture(bump, <span class="hljs-string">&quot;mBumpDiffuse&quot;</span>);
BumpShaderSetNormalTexture(bump, <span class="hljs-string">&quot;mBumpNormal&quot;</span>);
BumpShaderSetMaxLights(bump, <span class="hljs-number">3</span>);
</code></pre>
<p>Функция BumpShaderSetMaxLights задает количество источников света, которые должен учитывать шейдер. Напомним, что Xtreme3D поддерживает до 8 источников света - то же относится и к шейдеру рельефа.</p>
<p>Теперь можно создать материал и прикрепить к нему наш шейдер:</p>
<pre class="gml language-gml"><code class="hljs gml language-gml">MaterialCreate(<span class="hljs-string">&quot;mBump&quot;</span>, <span class="hljs-string">&quot;&quot;</span>);
MaterialSetAmbientColor(<span class="hljs-string">&quot;mBump&quot;</span>, <span class="hljs-symbol">c_black</span>, <span class="hljs-number">1</span>);
MaterialSetDiffuseColor(<span class="hljs-string">&quot;mBump&quot;</span>, <span class="hljs-symbol">c_white</span>, <span class="hljs-number">1</span>);
MaterialSetSpecularColor(<span class="hljs-string">&quot;mBump&quot;</span>, <span class="hljs-symbol">c_ltgray</span>, <span class="hljs-number">1</span>);
MaterialSetShininess(<span class="hljs-string">&quot;mBump&quot;</span>, <span class="hljs-number">32</span>);
MaterialSetShader(<span class="hljs-string">&quot;mBump&quot;</span>, bump);
</code></pre>
</body>
</html>

<!DOCTYPE html>
<html lang="ru">
<head>
    <title>Partition</title>
    <meta http-equiv="Content-Type" content="text/html; charset=windows-1251">
    <meta charset="windows-1251">
    <meta name="author" content="Gecko">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <link rel="stylesheet" type="text/css" href="../sakura.css" inline>
    <link rel="stylesheet" type="text/css" href="../github.css" inline>
</head>
<body>
<h1 id="partition">Partition</h1>
<p>Чем больше вы добавляете на сцену объектов, тем медленнее протекает их обработка и рендеринг. В таких ситуациях на отрисовку отправляется слишком много данных о вершинах, в том числе и тех, которые и рисоваться не должны - камера их просто не видит. Что же делать? На помощь приходят методы разбиения пространства. В частности, квадратичные и октарные деревья: Quadtree и Octree.</p>
<p>Рассмотрим принцип действия Octree. Игровой мир вписывается в куб, получившийся куб делится надвое по каждой оси (X,Y,Z). Таким образом, получается, что мир разбит на восемь кубов (отсюда и название Octree – восьмеричное дерево). Далее эти восемь кубов делятся еще на восемь, те еще на восемь и так далее.</p>
<p>Самый большой куб - исходный - называется корнем (root). Все кубы дерева, в том числе и корень – это узлы (node). Узлы, находящиеся в самом низу дерева и хранящие объекты - листья (leaf).</p>
<p>Когда сцена разбита на некоторе количество узлов, и в каждом листе хранятся списки принадлежащих ему объектов, мы, используя пирамиду видимости (frustum), определяем из всех листов те, которые видны камере. А определив их, рисуем только те объекты, которые находятся в кубах этих листьев.</p>
<p>Квадратичное дерево (Quadtree) устроено аналогично, только мир делится не на кубы, а на квадраты. Quadtree больше подходит для разбиения плоских пространств, в которых перемещение камеры ограничено преимущественно некоторой плоскостью: примером может служить автосимулятор.</p>
<p>Деревья могут применяться не только для отбора видимости, но и для оптимизации проверки столкновений. Например, вы можете определять листы, находящиеся внутри некоего ограничивающего параллелепипеда (AABB) или сферы (BSphere).</p>
<hr />
<h2 id="octreecreate">OctreeCreate</h2>
<p><code>real OctreeCreate(real maxdepth, real leafthreshold, real growgravy, real culling);</code></p>
<p>Создает октарное дерево и возвращает указатель на него.</p>
<ul>
<li><code>maxdepth</code> - сведения отсутствуют</li>
<li><code>leafthreshold</code> - сведения отсутствуют</li>
<li><code>growgravy</code> - сведения отсутствуют</li>
<li><code>culling</code> - сведения отсутствуют<ul>
<li><code>cmFineCulling</code> = 0</li>
<li><code>cmGrossCulling</code> = 1.</li></ul></li>
</ul>
<hr />
<h2 id="quadtreecreate">QuadtreeCreate</h2>
<p><code>real QuadtreeCreate(real maxdepth, real leafthreshold, real growgravy, real culling);</code></p>
<p>Создает квадратичное дерево и возвращает указатель на него.</p>
<ul>
<li><code>maxdepth</code> - сведения отсутствуют</li>
<li><code>leafthreshold</code> - сведения отсутствуют</li>
<li><code>growgravy</code> - сведения отсутствуют</li>
<li><code>culling</code> - сведения отсутствуют<ul>
<li><code>cmFineCulling</code> = 0</li>
<li><code>cmGrossCulling</code> = 1.</li></ul></li>
</ul>
<hr />
<h2 id="partitiondestroy">PartitionDestroy</h2>
<p><code>real PartitionDestroy(real tree);</code></p>
<p>Уничтожает дерево.</p>
<ul>
<li><code>tree</code> - указатель на дерево.</li>
</ul>
<hr />
<h2 id="partitionaddleaf">PartitionAddLeaf</h2>
<p><code>real PartitionAddLeaf(real tree, real object);</code></p>
<p>Добавляет к дереву объект, который должен участвовать в разбиении.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>object</code> - указатель на объект.</li>
</ul>
<hr />
<h2 id="partitionleafchanged">PartitionLeafChanged</h2>
<p><code>real PartitionLeafChanged(real object);</code></p>
<p>Сведения отсутствуют.</p>
<ul>
<li><code>object</code> - указатель на объект.</li>
</ul>
<hr />
<h2 id="partitionqueryfrustrum">PartitionQueryFrustrum</h2>
<p><code>real PartitionQueryFrustrum(real tree, real viewer);</code></p>
<p>Запрашивает у дерева все листья, которые видны камере заданного вида.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>viewer</code> - указатель на вид.</li>
</ul>
<hr />
<h2 id="partitionqueryleaf">PartitionQueryLeaf</h2>
<p><code>real PartitionQueryLeaf(real tree, real object);</code></p>
<p>Сведения отсутствуют.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>object</code> - указатель на объект.</li>
</ul>
<hr />
<h2 id="partitionqueryaabb">PartitionQueryAABB</h2>
<p><code>real PartitionQueryAABB(real tree, real object);</code></p>
<p>Запрашивает у дерева все листья, находящиеся внутри ограничивающего параллелепипеда заданного объекта.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>object</code> - указатель на объект.</li>
</ul>
<hr />
<h2 id="partitionquerybsphere">PartitionQueryBSphere</h2>
<p><code>real PartitionQueryBSphere(real tree, real object);</code></p>
<p>Запрашивает у дерева все листья, находящиеся внутри ограничивающей сферы заданного объекта.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>object</code> - указатель на объект.</li>
</ul>
<hr />
<h2 id="partitiongetnodetests">PartitionGetNodeTests</h2>
<p><code>real PartitionGetNodeTests(real tree);</code></p>
<p>Сведения отсутствуют.</p>
<ul>
<li><code>tree</code> - указатель на дерево.</li>
</ul>
<hr />
<h2 id="partitiongetnodecount">PartitionGetNodeCount</h2>
<p><code>real PartitionGetNodeCount(real tree);</code></p>
<p>Возвращает общее количество узлов дерева.</p>
<ul>
<li><code>tree</code> - указатель на дерево.</li>
</ul>
<hr />
<h2 id="partitiongetresult">PartitionGetResult</h2>
<p><code>real PartitionGetResult(real tree, real index);</code></p>
<p>Возвращает id объекта, принадлежащего заданному листу результата последнего запроса.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>index</code> - номер листа.</li>
</ul>
<hr />
<h2 id="partitiongetresultcount">PartitionGetResultCount</h2>
<p><code>real PartitionGetResultCount(real tree);</code></p>
<p>Возвращает количество листьев в результате последнего запроса.</p>
<ul>
<li><code>tree</code> - указатель на дерево</li>
<li><code>index</code> - номер листа.</li>
</ul>
<hr />
<h2 id="partitionresultshow">PartitionResultShow</h2>
<p><code>real PartitionResultShow(real tree);</code></p>
<p>Показывает объекты, принадлежащие листьям результата последнего запроса.</p>
<ul>
<li><code>tree</code> - указатель на дерево.</li>
</ul>
<hr />
<h2 id="partitionresulthide">PartitionResultHide</h2>
<p><code>real PartitionResultHide(real tree);</code></p>
<p>Скрывает объекты, принадлежащие листьям результата последнего запроса.</p>
<ul>
<li><code>tree</code> - указатель на дерево.</li>
</ul>
</body>
</html>

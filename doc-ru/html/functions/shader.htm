<HTML>
<HEAD>
<META http-equiv=Content-Type content="text/html; charset=windows-1251">
<TITLE>Shaders</TITLE>
<LINK href="../data/style.css" type=text/css rel=stylesheet>
</HEAD>
<BODY>

<DIV ALIGN=justify>

<H1 class=pagetitle>Shaders</H1>

<A class=type>Класс: TGLShader, TGLCelShader, TGLMultiMaterialShader, TGLHiddenLineShader, TGLOutlineShader, TGLTexCombineShader, TGLSLShader</A><BR><BR>

<A>Шейдер в Xtreme3D - это спецэффект для материала. Есть несколько видов шейдеров: Bump, Cel, HiddenLine, MultiMaterial, Outline, TexCombine, Phong и GLSL. Для применения шейдера к материалу используется функция </A><A class=funclink href=../functions/material.htm#MaterialSetShader>MaterialSetShader</A><A>. При помощи шейдеров на языке GLSL вы можете программировать свои собственные спецэффекты.
<BR><HR>

<A name="ShaderEnable"></A>
<H1 class=name>ShaderEnable</H1>
<A class=type>real</A><A> = </A><A class=function>ShaderEnable</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Включает или выключает шейдер.</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно).</A>
<HR>

<A name="BumpShaderCreate"></A>
<H1 class=name>BumpShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderCreate</A><A>( );</A>
<BR><A>Создает шейдер рельефа (bump mapping) и возвращает его id. С его помощью можно добиться очень эффектной имитации неровностей на поверхности модели. 
<BR>Данный шейдер требует поддержки расширений GL_ARB_shading_language (или GL_ARB_shading_language_100), GL_ARB_shader_objects, GL_ARB_vertex_shader, GL_ARB_fragment_shader.</A>
<HR>

<A name="BumpShaderSetDiffuseTexture"></A>
<H1 class=name>BumpShaderSetDiffuseTexture</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetDiffuseTexture</A><A>( shader as </A><A class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A>
<BR><A>Задает диффузную текстуру шейдера рельефа. Диффузная текстура - это обычная текстура, определяющая цвет поверхности объекта (а также прозрачность, если у нее есть альфа-канал).</A>
<BR><A>shader - id шейдера</A>
<BR><A>material - имя материала в текущей библиотеке, из которого следует читать текстуру. Если вместо имени указана пустая строка, то будет использована текстура материала, к которому подключен шейдер (текстура в слоте 0). Таким образом, один и тот же шейдер может работать с разными текстурами в зависимости от материала, что в некоторых ситуациях очень удобно.</A>
<HR>

<A name="BumpShaderSetNormalTexture"></A>
<H1 class=name>BumpShaderSetNormalTexture</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetNormalTexture</A><A>( shader as </A><A class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A>
<BR><A>Задает карту нормалей шейдера рельефа. Карта нормалей - это текстура, определяющая нормаль в каждой точке поверхности объекта (XYZ = RGB). BumpShader поддерживает карты нормалей в пространстве касательных (tangent space) - то есть, заданные в пространстве, где ось Z соответствует интерполированной нормали треугольника, а X и Y - взаимно перпендикулярным касательным к нормали (их также называют tangent и bitangent).</A>
<BR><A>shader - id шейдера</A>
<BR><A>material - имя материала в текущей библиотеке, из которого следует читать текстуру. Если вместо имени указана пустая строка, то будет использована вторая текстура материала, к которому подключен шейдер (текстура в слоте 1). Таким образом, один и тот же шейдер может работать с разными текстурами в зависимости от материала, что в некоторых ситуациях очень удобно.</A>
<HR>

<A name="BumpShaderSetHeightTexture"></A>
<H1 class=name>BumpShaderSetHeightTexture</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetHeightTexture</A><A>( shader as </A><A class=type>real</A><A>, material as </A><A class=type>string</A><A> );</A>
<BR><A>Задает карту высот шейдера рельефа. Карта высот - это текстура, темные элементы которой означают снижение высоты, а светлые - повышение. Карта высот необходима при использовании эффекта parallax mapping (см. ниже). Если этот эффект отключен, карта высот не требуется.</A>
<BR><A>shader - id шейдера</A>
<BR><A>material - имя материала в текущей библиотеке, из которого следует читать текстуру. Если вместо имени указана пустая строка, то будет использована третья текстура материала, к которому подключен шейдер (текстура в слоте 2). Таким образом, один и тот же шейдер может работать с разными текстурами в зависимости от материала, что в некоторых ситуациях очень удобно.</A>
<HR>

<A name="BumpShaderUseParallax"></A>
<H1 class=name>BumpShaderUseParallax</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderUseParallax</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Включает или выключает parallax mapping - эффект усиления иллюзии рельефа, достигаемый за счет смещения текстурных координат в зависимости от угла обзора. Этот эффект требует указания карты высот функцией </A>
<A class=funclink href=../functions/shader.htm#BumpShaderSetHeightTexture>BumpShaderSetHeightTexture<A><A>.</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно). По умолчанию parallax mapping выключен.</A>
<HR>

<A name="BumpShaderSetParallaxOffset"></A>
<H1 class=name>BumpShaderSetParallaxOffset</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetParallaxOffset</A><A>( shader,offset as </A><A class=type>real</A><A> );</A>
<BR><A>Задает коэффициент смещения для эффекта parallax mapping. Чем больше это значение, тем выше рельеф.</A>
<BR><A>shader - id шейдера</A>
<BR><A>offset - смещение. Значение по умолчанию: 0.03.</A>
<HR>

<A name="BumpShaderSetMaxLights"></A>
<H1 class=name>BumpShaderSetMaxLights</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetMaxLights</A><A>( shader,maxlights as </A><A class=type>real</A><A> );</A>
<BR><A>Задает количество источников света, которые должны учитываться шейдером рельефа. Это количество, как правило, меньше или равно числу источников света, созданных функцией </A><A class=funclink href=../functions/light.htm#LightCreate>LightCreate</A><A>. 
Соответственно, оно ограничено восемью - по максимальному количеству встроенных источников света OpenGL. Шейдер поддерживает все типы источников света: 
</A><A class=constant>lsOmni</A><A>, </A><A class=constant>lsSpot</A><A>, </A><A class=constant>lsParallel</A><A>.
<BR>Обратите также внимание, что состояние включенности/выключенности источников света, задаваемое функцией </A><A class=funclink href=../functions/light.htm#LightSetShining>LightSetShining</A><A>, игнорируется шейдером. Чтобы выключить источник света, можно функцией </A><A class=funclink href=../functions/light.htm#LightSetAttenuation>LightSetAttenuation</A><A> выставить в ноль его постоянную составляющую затухания (constant attenuation).
</A>
<BR><A>shader - id шейдера</A>
<BR><A>maxlights - количество источников света. Значение по умолчанию: 1.</A>
<HR>

<A name="BumpShaderSetShadowMap"></A>
<H1 class=name>BumpShaderSetShadowMap</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetShadowMap</A><A>( shader,shadowmap as </A><A class=type>real</A><A> );</A>
<BR><A>Задает теневую карту, которую шейдер рельефа должен использовать для отрисовки теней. По умолчанию теневая карта не присвоена, и шейдер не рендерит тени.</A>
<BR><A>shader - id шейдера</A>
<BR><A>shadowmap - id теневой карты. Если в этот параметр передать 0, то тени будут выключены.</A>
<HR>

<A name="BumpShaderSetShadowBlurRadius"></A>
<H1 class=name>BumpShaderSetShadowBlurRadius</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderSetShadowBlurRadius</A><A>( shader,radius as </A><A class=type>real</A><A> );</A>
<BR><A>Если шейдеру рельефа присвоена теневая карта, то эта функция задает радиус PCF-фильтрации теневой карты - в итоге, получаются мягкие тени.</A>
<BR><A>shader - id шейдера</A>
<BR><A>radius - радиус размытия. Значение 0 означает отсутствие фильтрации (тени будут резкими). Рекомендуется выставлять значения радиуса от 1 до 3 - более высокие значения могут снизить производительность. Значение по умолчанию - 0.</A>
<HR>

<A name="BumpShaderUseAutoTangentSpace"></A>
<H1 class=name>BumpShaderUseAutoTangentSpace</H1>
<A class=type>real</A><A> = </A><A class=function>BumpShaderUseAutoTangentSpace</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Некоторые виды объектов Xtreme3D не предоставляют шейдерам информацию о пространстве касательных, необходимую для рендеринга рельефа - это актеры и встроенные примитивы. Данная функция решает эту проблему: она включает или выключает автоматическое генерирование касательного вектора и бинормали во фрагментном шейдере. Результат получается несколько менее качественный, чем при использовании полноценно предрассчитанных векторов - при сильном приближении видны ребра полигонов, но это зависит от того, есть ли разрывы (швы) в текстурных координатах модели. Если UV-развертка непрерывна, как у примитивов, то ребер заметно не будет.</A>
<BR><A>Для включения этой опции необходимо, чтобы у модели были текстурные координаты.</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно). По умолчанию опция выключена.</A>
<HR>

<A name="CelShaderCreate"></A>
<H1 class=name>CelShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>CelShaderCreate</A><A>();</A>
<BR><A>Создает так называемый cel-шейдер и возвращает его id. Этот тип шейдера используется для создания специального эффекта мультипликационного изображения. Он включает отрисовку контуров и упрощение модели освещения (свет и тень представлены четко разграниченными пятнами).
<BR>Данный шейдер требует поддержки расширений GL_ARB_vertex_program и GL_ARB_fragment_program.</A></A>
<HR>

<A name="CelShaderSetLineColor"></A>
<H1 class=name>CelShaderSetLineColor</H1>
<A class=type>real</A><A> = </A><A class=function>CelShaderSetLineColor</A><A>( shader,color as </A><A class=type>real</A><A> );</A>
<BR><A>Задает цвет контура в cel-шейдере.</A>
<BR><A>shader - id шейдера</A>
<BR><A>color - цвет.</A>
<HR>

<A name="CelShaderSetLineWidth"></A>
<H1 class=name>CelShaderSetLineWidth</H1>
<A class=type>real</A><A> = </A><A class=function>CelShaderSetLineWidth</A><A>( shader,width as </A><A class=type>real</A><A> );</A>
<BR><A>Задает толщину контура в cel-шейдере.</A>
<BR><A>shader - id шейдера</A>
<BR><A>width - ширина.</A>
<HR>

<A name="CelShaderSetOptions"></A>
<H1 class=name>CelShaderSetOptions</H1>
<A class=type>real</A><A> = </A><A class=function>CelShaderSetOptions</A><A>( shader,outlines,textured as </A><A class=type>real</A><A> );</A>
<BR><A>Задает опции cel-шейдера.</A>
<BR><A>shader - id шейдера</A>
<BR><A>outlines - указывает, рисовать ли контуры - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно)</A>
<BR><A>textured - указывает, использовать ли текстуру материала - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно).</A>
<HR>

<A name="HiddenLineShaderCreate"></A>
<H1 class=name>HiddenLineShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderCreate</A><A>();</A>
<BR><A>Создает шейдер скрытых линий. Скрытые линии в данном случае - это ребра полигонов, из которых состоят объекты. Обычно они не отображаются, но этот шейдер позволяет 
их увидеть.</A>
<HR>

<A name="HiddenLineShaderSetLineSmooth"></A>
<H1 class=name>HiddenLineShaderSetLineSmooth</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderSetLineSmooth</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Включает или выключает анти-алиасинг линий (по умолчанию отключен).</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно).</A>
<HR>

<A name="HiddenLineShaderSetSolid"></A>
<H1 class=name>HiddenLineShaderSetSolid</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderSetSolid</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Включает или выключает отображение самого материала (по умолчанию отключено).</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно).</A>
<HR>

<A name="HiddenLineShaderSetSurfaceLit"></A>
<H1 class=name>HiddenLineShaderSetSurfaceLit</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderSetSurfaceLit</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Включает или выключает влияние освещения на материал с шейдером.</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно).</A>
<HR>

<A name="HiddenLineShaderSetFrontLine"></A>
<H1 class=name>HiddenLineShaderSetFrontLine</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderSetFrontLine</A><A>( shader,width,color,p,f as </A><A class=type>real</A><A> );</A>
<BR><A>Задает параметры передних линий. Передние линии принадлежат полигонам, нормали которых повернуты в сторону наблюдателя.</A>
<BR><A>shader - id шейдера</A>
<BR><A>width - толщина</A>
<BR><A>color - толщина</A>
<BR><A>p - cведения отсутствуют (по умолчанию 65535)</A>
<BR><A>f - cведения отсутствуют.</A>
<HR>

<A name="HiddenLineShaderSetBackLine"></A>
<H1 class=name>HiddenLineShaderSetBackLine</H1>
<A class=type>real</A><A> = </A><A class=function>HiddenLineShaderSetBackLine</A><A>( shader,width,color,p,f as </A><A class=type>real</A><A> );</A>
<BR><A>Задает параметры задних линий. Задние линии принадлежат полигонам, нормали которых повернуты в противоположную сторону от наблюдателя.</A>
<BR><A>shader - id шейдера</A>
<BR><A>width - толщина</A>
<BR><A>color - толщина</A>
<BR><A>p - cведения отсутствуют (по умолчанию 65535)</A>
<BR><A>f - cведения отсутствуют.</A>
<HR>

<A name="MultiMaterialShaderCreate"></A>
<H1 class=name>MultiMaterialShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>MultiMaterialShaderCreate</A><A>( matlib as </A><A class=type>real</A><A> );</A>
<BR><A>Создает мультиматериальный шейдер и возвращает его id. Этот шейдер позволяет создать материал, состоящий из нескольких слоев других материалов, с собственными текстурами и параметрами. Эти материалы загружаются из отдельной библиотеки.
<BR>Этот чрезвычайно мощный шейдер будет главным образом полезен для имитации поверхностей, состоящих из нескольких веществ с различными свойствами: например, деревянный ящик, окованный металлом, или камень с вкраплениями лавы или кристаллов. 
Но ему можно найти и другие применения.
<BR>Не рекомендуется создавать слишком много слоев, иначе движок будет тормозить. Если вы хотите создать сложный многокомпонентный материал, то эффективнее будет использовать шейдер GLSL.</A>
<BR><A>matlib - id библиотеки материалов. Материалы будут накладываться в том порядке, в каком они были добавлены в библиотеку (то есть, первый материал будет внизу).</A>
<HR>

<A name="OutlineShaderCreate"></A>
<H1 class=name>OutlineShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>OutlineShaderCreate</A><A>( smooth as </A><A class=type>real</A><A> );</A>
<BR><A>Создает контурный шейдер и возвращает его id. Используется для простейшего мультипликационного эффекта - отрисовки контуров вокруг объекта.</A>
<BR><A>smooth - cведения отсутствуют.</A>
<HR>

<A name="OutlineShaderSetLineColor"></A>
<H1 class=name>OutlineShaderSetLineColor</H1>
<A class=type>real</A><A> = </A><A class=function>OutlineShaderSetLineColor</A><A>( shader,color as </A><A class=type>real</A><A> );</A>
<BR><A>Задает цвет контура в контурном шейдере.</A>
<BR><A>shader - id шейдера</A>
<BR><A>color - цвет.</A>
<HR>

<A name="OutlineShaderSetLineWidth"></A>
<H1 class=name>OutlineShaderSetLineWidth</H1>
<A class=type>real</A><A> = </A><A class=function>OutlineShaderSetLineWidth</A><A>( shader,width as </A><A class=type>real</A><A> );</A>
<BR><A>Задает толщину контура в контурном шейдере.</A>
<BR><A>shader - id шейдера</A>
<BR><A>width - ширина.</A>
<HR>

<A name="TexCombineShaderCreate"></A>
<H1 class=name>TexCombineShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>TexCombineShaderCreate</A><A>( matlib as </A><A class=type>real</A><A> );</A>
<BR><A>Создает шейдер комбинирования текстур и возвращает его id. Этот шейдер позволяет вам запрограммировать простейшие операции с текстурами: суммирование, вычитание, умножение и т.д. - это что-то наподобие языка описания шейдеров, который работает только с текстурами. Шейдер поддерживает до 4 текстур - первые две задаются автоматически (это первая и вторая текстуры первого материала в библиотеке), третья и четвертая задаются вручную соответствующими функциями.</A>
<BR><A>matlib - id библиотеки материалов, из которой будут читаться текстуры.</A>
<HR>

<A name="TexCombineShaderMaterial3"></A>
<H1 class=name>TexCombineShaderMaterial3</H1>
<A class=type>real</A><A> = </A><A class=function>TexCombineShaderMaterial3</A><A>( shader as </A><A class=type>real</A><A>, material as </A><A class=type>real</A><A> );</A>
<BR><A>Задает материал, из которого нужно прочитать третью текстуру для шейдера комбинирования текстур.</A>
<BR><A>shader - id шейдера</A>
<BR><A>material - имя материала.</A>
<HR>

<A name="TexCombineShaderMaterial4"></A>
<H1 class=name>TexCombineShaderMaterial4</H1>
<A class=type>real</A><A> = </A><A class=function>TexCombineShaderMaterial4</A><A>( shader as </A><A class=type>real</A><A>, material as </A><A class=type>real</A><A> );</A>
<BR><A>Задает материал, из которого нужно прочитать четвертую текстуру для шейдера комбинирования текстур.</A>
<BR><A>shader - id шейдера</A>
<BR><A>material - имя материала.</A>
<HR>

<A name="TexCombineShaderAddCombiner"></A>
<H1 class=name>TexCombineShaderAddCombiner</H1>
<A class=type>real</A><A> = </A><A class=function>TexCombineShaderAddCombiner</A><A>( shader as </A><A class=type>real</A><A>, instruction as </A><A class=type>string</A><A> );</A>
<BR><A>Добавляет новый комбинатор - то есть, инструкцию для комбинирования текстур. Синтаксис инструкции напоминает операцию присваивания в Pascal. Доступны четыре обозначения текстурных слоев (Tex0, Tex1, Tex2, Tex3), к которым можно добавлять суффиксы ".а" и ".rgb" для получения по отдельности альфа-канала и значений RGB, соответственно. Также поддерживаются идентификатор PrimaryColor (или просто Col) - основной цвет (освещенность вершины), функции Interpolate (интерполяция между двумя текстурами) и Dot3 (скалярное произведение текстур).</A>
<BR><A>Результатом работы шейдера будет комбинатор с наибольшим индексом.</A>
<BR><A>shader - id шейдера</A>
<BR><A>instruction - строка, содержащая инструкцию. Вот несколько примеров инструкций:</A>
<BR><A>"Tex1:=Tex0;" - закрашивание первой текстурой</A>
<BR><A>"Tex1:=Tex0+Tex1;" - суммирование первых двух текстур</A>
<BR><A>"Tex1:=Tex0-Tex1;" - вычитание второй текстуры из первой</A>
<BR><A>"Tex1:=Tex0*Tex1;" - умножение первых двух текстур</A>
<BR><A>"Tex1:=Interpolate(Tex0,Tex1,PrimaryColor);" - интерполяция между первыми двумя текстурами с использованием освещенности в качестве параметра (то есть, текстура на освещенной стороне будет плавно переходить в текстуру на теневой стороне)</A>
<BR><A>"Tex1:=Dot3(Tex0,Tex1);" - скалярное произведение первых двух текстур.</A>
<HR>

<A name="PhongShaderCreate"></A>
<H1 class=name>PhongShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>PhongShaderCreate</A><A>( );</A>
<BR><A>Создает шейдер Фонга, реализующий попиксельное освещение с бликами по Блинну-Фонгу (Blinn-Phong), и возвращает его id. 
<BR><A>Данный шейдер требует поддержки расширений GL_ARB_shading_language (или GL_ARB_shading_language_100), GL_ARB_shader_objects, GL_ARB_vertex_shader, GL_ARB_fragment_shader.</A>
<HR>

<A name="PhongShaderUseTexture"></A>
<H1 class=name>PhongShaderUseTexture</H1>
<A class=type>real</A><A> = </A><A class=function>PhongShaderUseTexture</A><A>( shader,mode as </A><A class=type>real</A><A> );</A>
<BR><A>Определяет, учитывать ли текстуру в шейдере Фонга. Используется текстура материала, к которому подключен шейдер (текстура в слоте 0). 
<BR>Помимо цвета, текстура определяет также прозрачность объекта, если у нее есть альфа-канал. Если эта опция отключена, для задания прозрачности используется значение альфа диффузной компоненты материала, к которому подключен шейдер.</A>
<BR><A>shader - id шейдера</A>
<BR><A>mode - </A><A class=constant>true</A><A> или </A><A class=constant>false</A><A> (1 и 0 соответственно). По умолчанию текстура выключена.</A>
<HR>

<A name="PhongShaderSetMaxLights"></A>
<H1 class=name>PhongShaderSetMaxLights</H1>
<A class=type>real</A><A> = </A><A class=function>PhongShaderSetMaxLights</A><A>( shader,maxlights as </A><A class=type>real</A><A> );</A>
<BR><A>Задает количество источников света, которые должны учитываться шейдером Фонга. Это количество, как правило, меньше или равно числу источников света, созданных функцией </A><A class=funclink href=../functions/light.htm#LightCreate>LightCreate</A><A>. 
Соответственно, оно ограничено восемью - по максимальному количеству встроенных источников света OpenGL. Шейдер поддерживает все типы источников света: 
</A><A class=constant>lsOmni</A><A>, </A><A class=constant>lsSpot</A><A>, </A><A class=constant>lsParallel</A><A>.
<BR>Обратите также внимание, что состояние включенности/выключенности источников света, задаваемое функцией </A><A class=funclink href=../functions/light.htm#LightSetShining>LightSetShining</A><A>, игнорируется шейдером. Чтобы выключить источник света, можно функцией </A><A class=funclink href=../functions/light.htm#LightSetAttenuation>LightSetAttenuation</A><A> выставить в ноль его постоянную составляющую затухания (constant attenuation).
</A>
<BR><A>shader - id шейдера</A>
<BR><A>maxlights - количество источников света. Значение по умолчанию: 1.</A>
<HR>

<A name="GLSLShaderCreate"></A>
<H1 class=name>GLSLShaderCreate</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderCreate</A><A>( vertexshader,fragmentshader as </A><A class=type>string</A><A> );</A>
<BR><A>Создает шейдер GLSL и возвращает его id. GLSL (OpenGL Shading Language) - это язык описания шейдеров, при помощи которого вы можете запрограммировать графический конвейер (иными словами, управлять рендерингом объектов на вершинном и пиксельном уровне). За обработку вершин отвечает вершинная программа, за обработку пикселей - фрагментная.</A>
<BR><A>Данный шейдер требует поддержки расширений GL_ARB_shading_language (или GL_ARB_shading_language_100), GL_ARB_shader_objects, GL_ARB_vertex_shader, GL_ARB_fragment_shader.</A>
<BR><A>vertexshader - строка, содержащая вершинную программу GLSL (не имя файла!)</A>
<BR><A>fragmentshader - строка, содержащая фрагментную программу GLSL (не имя файла!)</A>
<BR><A>Если в функцию будет передана некорректная программа, будет выведено сообщение об ошибке, и движок продолжит работу.</A>
<HR>

<A name="GLSLShaderCreateParameter"></A>
<H1 class=name>GLSLShaderCreateParameter</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderCreateParameter</A><A>( shader as </A><A class=type>real</A><A>, name as </A><A class=type>real</A><A> );</A>
<BR><A>Создает новый параметр шейдера и возвращает его id. Эти параметры соответствуют uniform-переменным GLSL. Их можно модифицировать динамически в вашей игре, но в шейдере они доступны только для чтения.</A>
<BR><A>shader - id шейдера</A>
<BR><A>name - имя параметра.</A>
<HR>

<A name="GLSLShaderSetParameter1i"></A>
<H1 class=name>GLSLShaderSetParameter1i</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameter1i</A><A>( param,value as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера значение типа int (целое число).</A>
<BR><A>param - id параметра</A>
<BR><A>value - значение.</A>
<HR>

<A name="GLSLShaderSetParameter1f"></A>
<H1 class=name>GLSLShaderSetParameter1f</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameter1f</A><A>( param,value as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера значение типа float (вещественное число).</A>
<BR><A>param - id параметра</A>
<BR><A>value - значение.</A>
<HR>

<A name="GLSLShaderSetParameter2f"></A>
<H1 class=name>GLSLShaderSetParameter2f</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameter2f</A><A>( param,x,y as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера значение типа vec2 (вектор из двух вещественных чисел).</A>
<BR><A>param - id параметра</A>
<BR><A>x,y - вектор.</A>
<HR>

<A name="GLSLShaderSetParameter3f"></A>
<H1 class=name>GLSLShaderSetParameter3f</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameter3f</A><A>( param,x,y,z as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера значение типа vec3 (вектор из трех вещественных чисел).</A>
<BR><A>param - id параметра</A>
<BR><A>x,y,z - вектор.</A>
<HR>

<A name="GLSLShaderSetParameter4f"></A>
<H1 class=name>GLSLShaderSetParameter4f</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameter4f</A><A>( param,x,y,z,w as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера значение типа vec4 (вектор из четырех вещественных чисел).</A>
<BR><A>param - id параметра</A>
<BR><A>x,y,z,w - вектор.</A>
<HR>

<A name="GLSLShaderSetParameterTexture"></A>
<H1 class=name>GLSLShaderSetParameterTexture</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterTexture</A><A>( param as </A><A class=type>real</A><A>, material as </A><A class=type>string</A><A>, texunit as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текстуру заданного материала. Тип текстуры (sampler2D, samplerCube и пр.) устанавливается автоматически.</A>
<BR><A>param - id параметра</A>
<BR><A>material - имя материала (в активной библиотеке материалов). Если вместо имени указана пустая строка, то будет использована текстура материала, к которому подключен шейдер (текстура в слоте с индексом texunit). Таким образом, один и тот же шейдер может работать с разными текстурами в зависимости от материала, что в некоторых ситуациях очень удобно.</A>
<BR><A>texunit - определяет, через какой текстурный блок передавать текстуру. Стандарт OpenGL гаранирует 8 доступных текстурных блоков (0-7) - у современных видеокарт их может быть и больше (до 16 и даже 32), но для лучшей совместимости лучше не использовать больше 8. При автоматическом использовании текстуры материала (см. пояснение к предыдущему аргументу), номер текстурного блока соответствует текстурному слоту материала, а их количество также равно 8. В одном шейдере нельзя передавать две разные текстуры через один и тот же текстурный блок.</A>
<HR>

<A name="GLSLShaderSetParameterSecondTexture"></A>
<H1 class=name>GLSLShaderSetParameterSecondTexture</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterSecondTexture</A><A>( param as </A><A class=type>real</A><A>, material as </A><A class=type>string</A><A>, texunit as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера вторую текстуру заданного материала. Тип текстуры (sampler2D, samplerCube и пр.) устанавливается автоматически.</A>
<BR><A>param - id параметра</A>
<BR><A>material - имя материала (в активной библиотеке материалов). Если вместо имени указана пустая строка, то будет использована вторая текстура материала, к которому подключен шейдер.</A>
<BR><A>texunit - определяет, через какой текстурный блок передавать текстуру.</A>
<HR>

<A name="GLSLShaderSetParameterHasTextureEx"></A>
<H1 class=name>GLSLShaderSetParameterHasTextureEx</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterHasTextureEx</A><A>( param,index as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера (int или bool) единицу, если у материала, к которому подключен шейдер, есть текстура в заданном текстурном блоке, и ноль в противном случае.</A>
<BR><A>param - id параметра</A>
<BR><A>index - индекс текстурного слота (от 0 до 7 включительно).</A>
<HR>

<A name="GLSLShaderSetParameterMatrix"></A>
<H1 class=name>GLSLShaderSetParameterMatrix</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterMatrix</A><A>( param,object as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера абсолютную матрицу трансформации заданного объекта (тип mat4).</A>
<BR><A>param - id параметра</A>
<BR><A>object - id объекта.</A>
<HR>

<A name="GLSLShaderSetParameterInvMatrix"></A>
<H1 class=name>GLSLShaderSetParameterInvMatrix</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterInvMatrix</A><A>( param,object as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера обратную абсолютную матрицу трансформации заданного объекта (тип mat4).</A>
<BR><A>param - id параметра</A>
<BR><A>object - id объекта.</A>
<HR>

<A name="GLSLShaderSetParameterViewMatrix"></A>
<H1 class=name>GLSLShaderSetParameterViewMatrix</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterViewMatrix</A><A>( param as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текущую видовую матрицу (тип mat4), которая переносит точки и векторы из мирового пространства в видовое, где началом координат является позиция камеры, через которую совершается рендеринг. Параметр автоматически обновляется при трансформации камеры.</A>
<BR><A>param - id параметра.</A>
<HR>

<A name="GLSLShaderSetParameterInvViewMatrix"></A>
<H1 class=name>GLSLShaderSetParameterInvViewMatrix</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterInvViewMatrix</A><A>( param as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текущую обратную видовую матрицу (тип mat4), которая переносит точки и векторы из видового пространства в мировое. Параметр автоматически обновляется при трансформации камеры.</A>
<BR><A>param - id параметра.</A>
<HR>

<A name="GLSLShaderSetParameterShadowTexture"></A>
<H1 class=name>GLSLShaderSetParameterShadowTexture</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterShadowTexture</A><A>( param,shadowmap,texunit as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текстуру буфера теневой карты. В GLSL она имеет тип sampler2DShadow. С помощью этой текстуры можно реализовать в шейдере рендеринг теней.</A>
<BR><A>param - id параметра</A>
<BR><A>shadowmap - id теневой карты</A>
<BR><A>texunit - определяет, через какой текстурный блок передавать текстуру.</A>
<HR>

<A name="GLSLShaderSetParameterShadowMatrix"></A>
<H1 class=name>GLSLShaderSetParameterShadowMatrix</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterShadowMatrix</A><A>( param,shadowmap as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера теневую матрицу из теневой карты (тип mat4). Эта матрица отображает векторы модельно-видового пространства в пространство отсечения теневого буфера.</A>
<BR><A>param - id параметра</A>
<BR><A>object - id объекта.</A>
<HR>

<A name="GLSLShaderSetParameterFBOColorTexture"></A>
<H1 class=name>GLSLShaderSetParameterFBOColorTexture</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterFBOColorTexture</A><A>( param,fbo,texunit as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текстуру цветового буфера FBO.</A>
<BR><A>param - id параметра</A>
<BR><A>fbo - id FBO</A>
<BR><A>texunit - определяет, через какой текстурный блок передавать текстуру.</A>
<HR>

<A name="GLSLShaderSetParameterFBODepthTexture"></A>
<H1 class=name>GLSLShaderSetParameterFBODepthTexture</H1>
<A class=type>real</A><A> = </A><A class=function>GLSLShaderSetParameterFBODepthTexture</A><A>( param,fbo,texunit as </A><A class=type>real</A><A> );</A>
<BR><A>Передает в параметр шейдера текстуру Z-буфера FBO.</A>
<BR><A>param - id параметра</A>
<BR><A>fbo - id FBO</A>
<BR><A>texunit - определяет, через какой текстурный блок передавать текстуру.</A>
<HR>

</DIV>

</BODY>
</HTML>
